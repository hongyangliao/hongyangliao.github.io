<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[slf4j+logback配置详解]]></title>
    <url>%2F2018%2F01%2F03%2FLog%2Fslf4j-logback%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[近来在重构项目,原有项目日志部分使用SpringBoot的默认配置 默认情况下，Spring Boot会用Logback来记录日志,如果依赖了spring-boot-starter或者spring-boot-starter-logging则使用在spring-boot-1...RELEASE.jar下org/springframework/boot/logging/logback中的base.xml defaults.xml console-appender.xml file-appender.xml作为配置文件 网上发现一个logback的配置详解,地址为https://segmentfault.com/a/1190000008315137 留下作为记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="/apps/log/ducetech"/&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="ducetech-upms"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="appLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，false：表示只用当前logger的appender-ref，true：表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;!--&lt;logger name="org.hibernate" level="error"&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!-- druid logger --&gt; &lt;logger name="druid.sql" level="info" additivity="false"&gt; &lt;appender-ref ref="stdout"/&gt; &lt;/logger&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="error" additivity="false"&gt; &lt;appender-ref ref="stdout"/&gt; &lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="stdout"/&gt; &lt;appender-ref ref="appLogAppender"/&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>Log</category>
      </categories>
      <tags>
        <tag>slf4j</tag>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Mybatis时使用Druid数据库连接池]]></title>
    <url>%2F2018%2F01%2F02%2FSpring%2FSpringBoot%E6%95%B4%E5%90%88Mybatis%E6%97%B6%E4%BD%BF%E7%94%A8Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在SpringBoot项目中,增加如下依赖1234567891011121314151617181920 &lt;!-- spring mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.26&lt;/version&gt;&lt;/dependency&gt; 在resource目录下,创建jdbc.properties配置文件,加入以下配置1234567891011121314151617181920212223242526272829303132#数据库配置spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsespring.datasource.username=adminspring.datasource.password=adminspring.datasource.driver-class-name=com.mysql.jdbc.Driver# 连接池配置# 初始化大小，最小，最大spring.datasource.initialSize=5 spring.datasource.minIdle=5 spring.datasource.maxActive=20 # 配置获取连接等待超时的时间spring.datasource.maxWait=60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.timeBetweenEvictionRunsMillis=60000 # 配置一个连接在池中最小生存的时间，单位是毫秒spring.datasource.minEvictableIdleTimeMillis=300000# 测试连接是否有效的sqlspring.datasource.validationQuery=select 'x'# 建议配置为true，不影响性能，并且保证安全性# 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效spring.datasource.testWhileIdle=true# 申请连接时执行validationQuery检测连接是否有效spring.datasource.testOnBorrow=false# 归还连接时执行validationQuery检测连接是否有效spring.datasource.testOnReturn=false# 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：# 监控统计用的filter:stat# 日志用的filter:log4j# 防御sql注入的filter:wallspring.datasource.filters=stat,log4j,wall 创建数据源配置类DataSourceConfig.java,代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291package com.liao.mybatis;import com.alibaba.druid.pool.DruidDataSource;import org.mybatis.spring.annotation.MapperScan;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.sql.SQLException;/** * 数据源 * * @author hongyangliao * @ClassName: DataSourceConfig * @Date 18-1-2 下午8:56 */@Configuration@MapperScan("com.liao.**.dao")public class DataSourceConfig &#123; private static final Logger logger = LoggerFactory.getLogger(DataSourceConfig.class); @Autowired private JdbcConfig jdbcConfig; @Bean @Primary //在同样的DataSource中，首先使用被标注的DataSource public DataSource dataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(jdbcConfig.getUrl()); druidDataSource.setUsername(jdbcConfig.getUserName()); druidDataSource.setPassword(jdbcConfig.getPassword()); druidDataSource.setInitialSize(jdbcConfig.getInitialSize()); druidDataSource.setMinIdle(jdbcConfig.getMinIdle()); druidDataSource.setMaxActive(jdbcConfig.getMaxActive()); druidDataSource.setTimeBetweenEvictionRunsMillis(jdbcConfig.getTimeBetweenEvictionRunsMillis()); druidDataSource.setMinEvictableIdleTimeMillis(jdbcConfig.getMinEvictableIdleTimeMillis()); druidDataSource.setValidationQuery(jdbcConfig.getValidationQuery()); druidDataSource.setTestWhileIdle(jdbcConfig.isTestWhileIdle()); druidDataSource.setTestOnBorrow(jdbcConfig.isTestOnBorrow()); druidDataSource.setTestOnReturn(jdbcConfig.isTestOnReturn()); druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(jdbcConfig.getMaxPoolPreparedStatementPerConnectionSize()); try &#123; druidDataSource.setFilters(jdbcConfig.getFilters()); &#125; catch (SQLException e) &#123; if (logger.isInfoEnabled()) &#123; logger.info(e.getMessage(), e); &#125; &#125; return druidDataSource; &#125; /** * Jdbc配置类 * * @author hongyangliao * @ClassName: JdbcConfig * @Date 18-1-2 下午9:00 */ @PropertySource(value = "classpath:jdbc.properties") @Component public static class JdbcConfig &#123; /** * 数据库用户名 */ @Value("$&#123;spring.datasource.username&#125;") private String userName; /** * 驱动名称 */ @Value("$&#123;spring.datasource.driver-class-name&#125;") private String driverClass; /** * 数据库连接url */ @Value("$&#123;spring.datasource.url&#125;") private String url; /** * 数据库密码 */ @Value("$&#123;spring.datasource.password&#125;") private String password; /** * 数据库连接池初始化大小 */ @Value("$&#123;spring.datasource.initialSize&#125;") private int initialSize; /** * 数据库连接池最小最小连接数 */ @Value("$&#123;spring.datasource.minIdle&#125;") private int minIdle; /** * 数据库连接池最大连接数 */ @Value("$&#123;spring.datasource.maxActive&#125;") private int maxActive; /** * 获取连接等待超时的时间 */ @Value("$&#123;spring.datasource.maxWait&#125;") private long maxWait; /** * 多久检测一次 */ @Value("$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;") private long timeBetweenEvictionRunsMillis; /** * 连接在池中最小生存的时间 */ @Value("$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;") private long minEvictableIdleTimeMillis; /** * 测试连接是否有效的sql */ @Value("$&#123;spring.datasource.validationQuery&#125;") private String validationQuery; /** * 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，检测连接是否有效 */ @Value("$&#123;spring.datasource.testWhileIdle&#125;") private boolean testWhileIdle; /** * 申请连接时,检测连接是否有效 */ @Value("$&#123;spring.datasource.testOnBorrow&#125;") private boolean testOnBorrow; /** * 归还连接时,检测连接是否有效 */ @Value("$&#123;spring.datasource.testOnReturn&#125;") private boolean testOnReturn; /** * PSCache大小 */ @Value("$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;") private int maxPoolPreparedStatementPerConnectionSize; /** * 通过别名的方式配置扩展插件 */ @Value("$&#123;spring.datasource.filters&#125;") private String filters; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getDriverClass() &#123; return driverClass; &#125; public void setDriverClass(String driverClass) &#123; this.driverClass = driverClass; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getInitialSize() &#123; return initialSize; &#125; public void setInitialSize(int initialSize) &#123; this.initialSize = initialSize; &#125; public int getMinIdle() &#123; return minIdle; &#125; public void setMinIdle(int minIdle) &#123; this.minIdle = minIdle; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public long getMaxWait() &#123; return maxWait; &#125; public void setMaxWait(long maxWait) &#123; this.maxWait = maxWait; &#125; public long getTimeBetweenEvictionRunsMillis() &#123; return timeBetweenEvictionRunsMillis; &#125; public void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) &#123; this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis; &#125; public long getMinEvictableIdleTimeMillis() &#123; return minEvictableIdleTimeMillis; &#125; public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) &#123; this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis; &#125; public String getValidationQuery() &#123; return validationQuery; &#125; public void setValidationQuery(String validationQuery) &#123; this.validationQuery = validationQuery; &#125; public boolean isTestWhileIdle() &#123; return testWhileIdle; &#125; public void setTestWhileIdle(boolean testWhileIdle) &#123; this.testWhileIdle = testWhileIdle; &#125; public boolean isTestOnBorrow() &#123; return testOnBorrow; &#125; public void setTestOnBorrow(boolean testOnBorrow) &#123; this.testOnBorrow = testOnBorrow; &#125; public boolean isTestOnReturn() &#123; return testOnReturn; &#125; public void setTestOnReturn(boolean testOnReturn) &#123; this.testOnReturn = testOnReturn; &#125; public int getMaxPoolPreparedStatementPerConnectionSize() &#123; return maxPoolPreparedStatementPerConnectionSize; &#125; public void setMaxPoolPreparedStatementPerConnectionSize(int maxPoolPreparedStatementPerConnectionSize) &#123; this.maxPoolPreparedStatementPerConnectionSize = maxPoolPreparedStatementPerConnectionSize; &#125; public String getFilters() &#123; return filters; &#125; public void setFilters(String filters) &#123; this.filters = filters; &#125; &#125;&#125; 创建Session工厂配置类SessionFactoryConfig.java,代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.liao.mybatis;import java.io.IOException;import javax.sql.DataSource;import org.mybatis.spring.SqlSessionFactoryBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.ClassPathResource;import org.springframework.transaction.annotation.EnableTransactionManagement;@Configuration@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt;public class SessionFactoryConfig &#123; /** * mybatis 配置路径 */ private static String MYBATIS_CONFIG = "mybatis-config.xml"; @Autowired private DataSource dataSource; /*** * 创建sqlSessionFactoryBean * 并且设置configtion 如驼峰命名.等等 * 设置mapper 映射路径 * 设置datasource数据源 * * @Title: createSqlSessionFactoryBean * @author: hongyangliao * @Date: 18-1-3 上午9:52 * @param * @return org.mybatis.spring.SqlSessionFactoryBean sqlSessionFactoryBean实例 * @throws */ @Bean(name = "sqlSessionFactory") public SqlSessionFactoryBean createSqlSessionFactoryBean() throws IOException &#123; SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean(); // 设置mybatis configuration 扫描路径 sqlSessionFactory.setConfigLocation(new ClassPathResource(MYBATIS_CONFIG)); // 设置datasource sqlSessionFactory.setDataSource(dataSource); return sqlSessionFactory; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nginx作为静态文件服务器]]></title>
    <url>%2F2017%2F12%2F20%2FNginx%2F%E4%BD%BF%E7%94%A8nginx%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍:自己希望搭建个文件服务器用来下载常用的开发软件修改nginx的配置文件,加上如下内容12345678910111213141516server &#123; listen 80; # 填写域名或者ip地址 server_name test.hongyangliao.com; # 文件存储目录 root /data; location / &#123; # 显示索引 autoindex on; # 显示大小 autoindex_exact_size on; # 显示时间 autoindex_localtime on; &#125;&#125; 重启nginx服务,输入test.hongyangliao.com即可查看,页面如下图所示1234567891011Index of /../apache-maven-3.5.2-bin.tar.gz 20-Dec-2017 02:30 8738691apache-tomcat-7.0.82.tar.gz 20-Dec-2017 02:30 8997403apache-tomcat-8.0.48.tar.gz 20-Dec-2017 02:30 9390469apache-tomcat-8.5.24.tar.gz 20-Dec-2017 02:30 9487006jdk-7u80-linux-x64.tar.gz 20-Dec-2017 02:52 153530841jdk-8u151-linux-x64.tar.gz 20-Dec-2017 01:20 189736377nginx-1.8.1.tar.gz 20-Dec-2017 00:25 833473redis-4.0.6.tar.gz 20-Dec-2017 02:31 1723533 点击相应的文件即可下载,如想在下载linux服务器下载,使用如下命令1wget http://test.hongyangliao.com/apache-maven-3.5.2-bin.tar.gz]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移gitolite]]></title>
    <url>%2F2017%2F12%2F08%2FGit%2F%E8%BF%81%E7%A7%BBgitolite%2F</url>
    <content type="text"><![CDATA[在新的服务器上安装gitolite,并为其指定管理员进入gitolite初始化后的目录gitolite-admin内，将之前线上config和keydir内文件全部拷贝过来git push,提交将原有的giolite的repositories下的文件拷贝到新服务器的repositories下在gitolite-admin中git pull获取最新的数据]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos6.5服务器安装]]></title>
    <url>%2F2017%2F11%2F29%2FLinux%2FCentos6-5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[关闭安全子系统12sed -i "s/SELINUX=enforcing/SELINUX=disabled/" /etc/selinux/configsetenforce 0 安装wget1yum -y install wget 更改默认镜像为阿里镜像1234cd /etc/yum.repos.d &amp;&amp; mv CentOS-Base.repo CentOS-Base.repo.bakwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repoyum makecacheyum clean all 安装zip1yum install -y unzip zip 安装vim1yum install -y vim 安装scp1yum -y install openssh-clients 安装相关依赖1yum -y install gcc-c++ tcl gettext-devel pcre-devel openssl openssl-devel bison flexcurl-devel expat-devel zlib-devel autoconf automake libtool python ncurses-devellibjpeg-devel e2fsprogs-devel sqlite-devel libcurl-devel speex-devel ldns-devel libeditdevelreadline-devel ncurses-devel pam-develnumactl 安装screen会话1yum -y install screen 安装ntpdate时间同步工具12yum -y install ntpdateecho '0 1 * * * ntpdate cn.pool.ntp.org;hwclock -w' &gt;&gt; /var/spool/cron/root 安装java123456789101112mkdir -p /opt/javacd ~ &amp;&amp; wget http://oss.hongyangliao.com/jdk-8u151-linux-x64.tar.gzmv jdk-8u151-linux-x64.tar.gz /opt/java/cd /opt/javatar -xzvf jdk-8u151-linux-x64.tar.gzrm -rf jdk-8u151-linux-x64.tar.gzecho 'export JAVA_HOME=/opt/java/jdk1.8.0_151' &gt;&gt; /etc/profileecho 'exportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar' &gt;&gt; /etc/profileecho 'export PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profilecd /usr/binln -s -f /opt/java/jdk1.8.0_151/jre/bin/javaln -s -f /opt/java/jdk1.8.0_151/bin/javac 安装Tomcat12345678cd ~ &amp;&amp; wget http://oss.hongyangliao.com/apache-tomcat-8.5.24.tar.gzmv apache-tomcat-8.5.24.tar.gz /usr/local/cd /usr/localtar -xzvf apache-tomcat-8.5.24.tar.gzmv apache-tomcat-8.5.24 tomcat8mv apache-tomcat-8.5.24.tar.gz /usr/local/srcecho 'export CATALINA_HOME=/usr/local/tomcat8' &gt;&gt; /etc/profilesource /etc/profile 设置Tomcat自启12cd /etc/init.dtouch tomcat8 &amp;&amp; chmod 755 tomcat8 &amp;&amp; vim tomcat8 添加如下命令,注意JAVA_HOME,CATALANA_HOME1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bash # # tomcat startup script for the Tomcat server # # chkconfig: 345 80 20 # description: start the tomcat deamon # # Source function library . /etc/rc.d/init.d/functionsprog=tomcat8JAVA_HOME=/opt/java/jdk1.8.0_151export JAVA_HOME CATALANA_HOME=/usr/local/tomcat8export CATALINA_HOME case "$1" instart) echo "Starting Tomcat..." $CATALANA_HOME/bin/startup.sh ;;stop) echo "Stopping Tomcat..." $CATALANA_HOME/bin/shutdown.sh ;;restart) echo "Stopping Tomcat..." $CATALANA_HOME/bin/shutdown.sh sleep 2 echo echo "Starting Tomcat..." $CATALANA_HOME/bin/startup.sh ;;*) echo "Usage: $prog &#123;start|stop|restart&#125;" ;;esacexit 0 执行以下命令12chkconfig --add tomcat8chkconfig --level 345 tomcat8 安装nginx下载并安装nginx12345cd &amp;&amp; wget http://oss.hongyangliao.com/nginx-1.8.1.tar.gzmv nginx-1.8.1.tar.gz /usr/local/srccd /usr/local/src &amp;&amp; tar -xzvf nginx-1.8.1.tar.gzcd nginx-1.8.1 &amp;&amp; ./configure --prefix=/usr/local/nginxmake &amp;&amp; make install 设置nginx自启123cd /etc/init.dtouch nginxvim nginx 添加如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!/bin/bash # nginx Startup script for the Nginx HTTP Server # # chkconfig: - 85 15 # description: Nginx is a high-performance web and proxy server. # It has a lot of features, but it's not for everyone. # processname: nginx # pidfile: /usr/local/nginx/logs/nginx.pid # config: /usr/local/nginx/conf/nginx.conf nginxd=/usr/local/nginx/sbin/nginx nginx_config=/usr/local/nginx/conf/nginx.conf nginx_pid=/usr/local/nginx/nginx.pid RETVAL=0 prog="nginx"# Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ $&#123;NETWORKING&#125; = "no" ] &amp;&amp; exit 0 [ -x $nginxd ] || exit 0 # Start nginx daemons functions. start() &#123; if [ -e $nginx_pid ];then echo "nginx already running...." exit 1 fi echo -n $"Starting $prog: " daemon $nginxd -c $&#123;nginx_config&#125; RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx return $RETVAL &#125; # Stop nginx daemons functions. stop() &#123; echo -n $"Stopping $prog: " killproc $nginxd RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid &#125; # reload nginx service functions. reload() &#123; echo -n $"Reloading $prog: " $nginxd -s reload #if your nginx version is below 0.8, please use this command: "kill -HUP `cat $&#123;nginx_pid&#125;`" RETVAL=$? echo &#125; # See how we were called. case "$1" instart) start ;; stop) stop ;; reload) reload ;; restart) stop start ;; status) status $prog RETVAL=$? ;; *) echo $"Usage: $prog &#123;start|stop|restart|reload|status|help&#125;" exit 1 esac exit $RETVAL 保存,接着设置自启1234chmod +x /etc/init.d/nginxchkconfig --add nginxchkconfig --level 345 nginx onservice nginx start 安装Redis12345cd &amp;&amp; wget http://oss.hongyangliao.com/redis-4.0.6.tar.gztar -zxvf redis-4.0.6.tar.gzcd redis-4.0.6 &amp;&amp; make PREFIX=/usr/local/redis installcd /usr/local/redis &amp;&amp; mkdir confcp ~/redis-4.0.6/redis.conf /usr/local/redis/conf 设置后端启动Redis1vim /usr/local/redis/conf/redis.conf 将 daemonize yes 以后端模式启动12345################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize yes 设置redis服务自启12cd /etc/init.d &amp;&amp; touch redis &amp;&amp; chmod +x redisvim redis 在redis文件中添加如下内容,注意redis_pid的值123cd /etc/init.dtouch redisvim redis 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/bin/bash## chkconfig: - 85 15# script_name:redisd# description:redis daemon# config: /usr/local/redis/conf/redisd.conf# pidfile: /var/run/redis-server.pid#### BEGIN INIT INFO# Provides: redis### END INIT INFO# Source function library.. /etc/rc.d/init.d/functions#variablesredis_port='6379'redis_pid='/var/run/redis_'$redis_port'.pid'redis_server="/usr/local/redis/bin/redis-server"redis_conf="/usr/local/redis/conf/redis.conf"redis_cli="/usr/local/redis/bin/redis-cli"#functionfunction _start() &#123; if [ ! -e "$redis_pid" ];then "$redis_server" "$redis_conf" echo "redis service start.......OK" return 0 else echo "redis service is running !" return 1 fi&#125;function _stop() &#123; if [ -e "$redis_pid" ];then "$redis_cli" shutdown echo "redis service stop.......OK" sleep 1 return 0 else echo "redis service is not running !" return 1 fi&#125;function _status() &#123; if [ -e "$redis_pid" ];then echo "redis service is running !" return 0 else echo "redis service is not running !" return 1 fi&#125;#maincase "$1" in start) _start ;; stop) _stop ;; status) _status ;; *) echo "Usage: $0 &#123;start|stop|status&#125;"esac 接着123chkconfig --add redischkconfig --level 345 redis onservice redis start 设置给redis客户端设置软链接1ln -s /usr/local/redis/bin/redis-cli /usr/local/bin/redis-cli 安装mysql123456789wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmrpm -ivh mysql-community-release-el6-5.noarch.rpmyum install mysql-server/etc/init.d/mysqld startmysql_secure_installationmysql -uroot -puse mysql;GRANT ALL PRIVILEGES ON *.* TO 'admin'@'%' IDENTIFIED BY 'admin' WITH GRANT OPTION;FLUSH PRIVILEGES; 修改mysql数据库编码为UTF-8，修改/etc/my.cnf或者/etc/mysql/my.cnf文件123456[client]default-character-set = utf8[mysqld]default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci 重启mysql服务，并查看数据库编码123service mysqld restartmysql -uroot -pshow variables like '%char%'; 编码为以下即可123456789101112+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 安装Maven12345678910cd ~ &amp;&amp; wget http://oss.hongyangliao.com/apache-maven-3.5.2-bin.tar.gzmv apache-maven-3.5.2-bin.tar.gz /usr/local/cd /usr/local &amp;&amp; tar -xzvf apache-maven-3.5.2-bin.tar.gzmv apache-maven-3.5.2 mavenecho 'M2_HOME=/usr/local/maven' &gt;&gt; /etc/profileecho 'export PATH=$M2_HOME/bin:$PATH' &gt;&gt; /etc/profilesource /etc/profilemvn help:systemcp /usr/local/maven/conf/settings.xml /root/.m2/mv /usr/local/apache-maven-3.2.5-bin.tar.gz /usr/local/src/ 安装Git1yum -y install git 配置公钥1ssh-keygen -t rsa]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitclone非22端口clone项目]]></title>
    <url>%2F2017%2F11%2F21%2FGit%2Fgitclone%E9%9D%9E22%E7%AB%AF%E5%8F%A3clone%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[使用git clone命令clone项目时，如果repository的SSH端口不是标准22端口时（例如，SSH tunnel模式，等等），可以使用如下命令：1git clone ssh://git@hostname:port/.../xxx.git]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库设置utf-8编码]]></title>
    <url>%2F2017%2F11%2F20%2Fmysql%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AEutf-8%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[修改/etc/my.cnf或者/etc/mysql/my.cnf文件123456[client]default-character-set = utf8[mysqld]default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci 重启mysql,使用mysql客户端检查编码1show variables like '%char%'; 创建新数据库时使用UTF-8编码1create database 'test' default character set utf8 collate utf8_general_ci; 创建表,创建字段使用UTF-8编码12345create table test ( 'id' int(10) unsigned not null auto_increment, 'name' varchar(50) character set utf8 default '', primary key('id') ) default charset=utf8;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat部署项目]]></title>
    <url>%2F2017%2F09%2F07%2FTomcat%2Ftomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[第一种方式 将项目打包成war，然后放入tomcat根目录/webapps下，启动tomcat，tomcat自动将war解压，然后删除war包,或者之间放入项目编译后的文件 第二种方式 项目放在任意目录，如/apps/hello-world 在tomcat根目录/conf中的server.xml的节点中加入 1&lt;Context path="/hello-world" docBase="/apps/hello-world"/&gt; 第三种方式(推荐) 项目放在任意目录，如/apps/hello-world 在tomcat根目录/conf中新建Catalina/localhost目录,在localhost目录中创建一个xml文件，文件名称任意(最好使用下项目名),在文件中加入 1&lt;Context path="/hello-world" docBase="/apps/hello-world"/&gt; 注意第三种方法的优点，可以定义别名。服务器端运行的项目名称为path，外部访问的URL则使用XML的文件名]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat用户配置]]></title>
    <url>%2F2017%2F08%2F30%2FTomcat%2Ftomcat%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[进入Tomcat目录下conf/tomcat-users.xml 1.Tomcat6配置管理员信息 在配置文件节点下添加 123&lt;role rolename="admin"/&gt;&lt;role rolename="manager"/&gt;&lt;user username="admin" password="admin" roles="admin,manager"/&gt; 2.Tomcat7配置管理员信息 在配置文件节点下添加 123&lt;role rolename="admin-gui"/&gt;&lt;role rolename="manager-gui"/&gt;&lt;user username="admin" password="admin" roles=" admin-gui,manager-gui "/&gt;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见操作]]></title>
    <url>%2F2017%2F08%2F29%2FLinux%2FLinux%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[注意事项：基于centos6 修改密码 passwd passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被root用户锁定；如果root用户运行passwd ，可以设置或修改任何用户的密码 passwd 命令后面不接任何参数或用户名，则表示修改当前用户的密码 修改主机名 hostname 1.使用hostname修改主机名 hostname hongyangliao-pc 2.修改/etc/sysconfig/network配置文件 修改HOSTNAME=hongyangliao-pc 3.修改本机域名解析文件/etc/hosts 将原来的主机名换为hongyangliao-pc 修改SSH端口 1.修改SSH端口配置文件/etc/ssh/sshd_config,将Port的值换为想要的端口号 2.重启SSH服务，service sshd restart iptabels配置 1.修改/etc/sysconfig/iptbles 文件 123456789101112131415161718192021222324*filter# Allow loopback (lo0) traffic and drop all traffic to 127/8 that doesn't use the lo0 interface-A INPUT -i lo -j ACCEPT-A INPUT -i ! lo -d 127.0.0.0/8 -j REJECT# Accept established inbound connections-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# Allow all outbound traffic-A OUTPUT -j ACCEPT# Allow HTTP and HTTPS connections-A INPUT -p tcp --dport 80 -j ACCEPT-A INPUT -p tcp --dport 443 -j ACCEPT# Allow SSH/SFTP# Change the value 22 if you are using a non-standard port-A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT# Allow FTP# Purely optional, but required for WordPress to install its own plugins or update itself.-A INPUT -p tcp -m state --state NEW --dport 21 -j ACCEPT# Allow PING# Again, optional. Some disallow this altogether.-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# Reject ALL other inbound-A INPUT -j REJECT-A FORWARD -j REJECTCOMMIT 2.保存 1service iptables save 3.重启 1service iptables restart 4.添加到自启动 1chkconfig iptables on ssh scp 免密码登录 1.本机创建公钥、密钥 ssh-keygen -t rsa 一路回车到底 2.把公钥id_rsa.pub复制到远程服务器上~/.ssh目录并命名为authorized_keys 远程复制scp 1.从本地复制到远程服务器 1# scp local_file remote_username@remote_ip:remote_folder 2.从远程服务器复制到本地 1# $scp remote_username@remote_ip:remote_file local_folder 网络设置 1.修改ip地址 修改对应网卡的ip地址 1# vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改以下内容 12345678910DEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0BOOTPROTO=static #设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址BROADCAST=192.168.0.255 #对应的子网广播地址HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址IPADDR=12.168.1.2 #如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址IPV6INIT=noIPV6_AUTOCONF=noNETMASK=255.255.255.0 #网卡对应的网络掩码NETWORK=192.168.1.0 #网卡对应的网络地址ONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备 2.修改网关 修改对应网卡的网关 1# vim /etc/sysconfig/network 修改以下内容 123NETWORKING=yes #表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动HOSTNAME=centos #设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应GATEWAY=192.168.1.1 #设置本机连接的网关的IP地址。例如，网关为10.0.0.2 3.修改DNS 修改对应网卡的DNS 1# vim /etc/resolv.conf 修改以下内容 12nameserver 8.8.8.8 #google域名服务器nameserver 8.8.4.4 #google域名服务器 4.重启网卡 1# /etc/init.d/network restart 5.简单设置(推荐) 修改对应网卡的网关 1# vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改以下内容 123456789BOOTPROTO=static #静态指定ipONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备IPADDR=192.168.149.10 #ip地址NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.149.2 #网关DNS1=8.8.8.8 #DNSDNS2=4.4.4.4IPV6INIT=noDEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0 重启网卡 1# /etc/init.d/network restart 安装Apache 1.停止并卸载系统自带的httpd服务 12345# service httpd stop# ps -ef | grep httpd# kill -9 pid号（逐个删除）# rpm -qa |grep httpd# rpm -e httpd软件包 2.安装Apache 12# wget http://mirrors.hust.edu.cn/apache//httpd/httpd-2.2.34.tar.gz# tar -zxvf httpd-2.2.34.tar.gz 3.编译 12# ./configure --prefix=/usr/local/apache# make &amp;&amp; make install 4.启动、停止、重启 启动Apache：/usr/local/apache2/bin/apachectl start 停止Apache：/usr/local/apache2/bin/apachectl stop 重启Apache：/usr/local/apache2/bin/apachectl restart 5.网站放置目录 网站放在/usr/local/apache/htdocs 安装php 1.安装依赖文件(不安装的话，自己会安装很多东西) 12# yum groupinstall "Development tools"# yum install libxml2-devel gd-devel libmcrypt-devel libcurl-devel openssl-devel 2.安装php 12# wget http://php.net/get/php-5.5.38.tar.gz/from/this/mirror# tar -zxvf php-5.5.38.tar.gz 3.编译 12# ./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache/bin/apxs --disable-cli --enable-shared --with-libxml-dir --with-gd --with-openssl --enable-mbstring --with-mysqli --with-mysql --enable-opcache --enable-mysqlnd --enable-zip --enable-fpm --enable-fastcgi --with-zlib-dir --with-pdo-mysql --with-jpeg-dir --with-freetype-dir --with-curl --without-pdo-sqlite --without-sqlite3 --with-mcrypt=/usr/local/libmcrypt/# make &amp;&amp; make install 4.注意事项 如果出现 configure: error: mcrypt.h not found. Please reinstall libmcrypt 则需安装libmcrypt 12345# wget ftp://mcrypt.hellug.gr/pub/crypto/mcrypt/attic/libmcrypt/libmcrypt-2.5.7.tar.gz# tar -zxvf libmcrypt-2.5.7.tar.gz# cd libmcrypt-2.5.7# ./configure prefix=/usr/local/libmcrypt/# make &amp;&amp; make install 5.配置Apache中的PHP环境 修改Apache的配置文件httpd.conf 在LoadModule中添加： 1LoadModule php5_module modules/libphp5.so 在AddType application/x-gzip .gz .tgz下面添加： 12AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps 在DirectoryIndex增加 index.php，以便Apache识别PHP格式的index 123&lt;IfModule dir_module&gt; DirectoryIndex index.html index.php &lt;/IfModule&gt; 6.验证PHP环境 1# vim /usr/local/apache/htdocs/info.php 添加如下代码 12345&lt;?phpphpinfo();?&gt; 访问 http://locahost/info.php 可查看很多信息 安转rar1.安装依赖库 1# yum install -y gcc gcc-c++ autoconf wget 2.下载源码包 1# wget http://www.rarlab.com/rar/rarlinux-x64-5.3.0.tar.gz 3.解压编译 123456tar -zxvf rarlinux-x64-5.3.0.tar.gzcd rarmake &amp;&amp; make installcp -f rar_static /usr/local/bin/rar &amp;&amp; cp -f rar_static /usr/local/bin/unrarcd ..rm -rf rar 4.使用 12解压：rar x filename.rar压缩：rar a targetName.rar dirName]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql导出、导入]]></title>
    <url>%2F2017%2F08%2F10%2Fmysql%2Fmysql%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[mysql导出数据库、表1.导出数据和表结构1# mysqldump -u用户名 -p密码 数据库名 &gt; 文件名.sql 2.导出单表数据核单表1# mysqldump -u用户名 -p密码 数据库名 表名 &gt; 文件名.sql 3.只导出表结构1mysqldump -u用户名 -p密码 -d 数据库名 &gt; 文件名.sql mysql导出sql文件1.首先创建数据库1create database 数据库名 2.导入数据库 方法一： （1）选择数据库1use 数据库名 （2）导入数据1source sql文件路径 方法二：1mysql -u用户名 -p密码 数据库名 &lt; sql文件路径]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud 微服务 开发步骤]]></title>
    <url>%2F2017%2F07%2F09%2FSpring%2FSpringCloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%20%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[参考：http://blog.didispace.com/springcloud1/创建一个基础的Spring Boot工程,每个项目都需加上SpringCloud的依赖使用的是Brixton版本 12345678910111213141516171819202122232425262728&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 一.服务注册中心a)加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; b)在主程序中加入注解@EnableEurekaServer 启动一个服务注册中心 c)默认情况下，注册中心会将自己作为客户端需要禁用,配置application.properties 1234server.port=1111eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/ 二.服务提供方a)加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; b)实现处理接口，通过DiscoveryClient获取信息 12345678910111213@RestControllerpublic class ComputeController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(value = "/add" ,method = RequestMethod.GET) public Integer add(@RequestParam Integer a, @RequestParam Integer b) &#123; ServiceInstance instance = client.getLocalServiceInstance(); Integer r = a + b; logger.info("/add, host:" + instance.getHost() + ", service_id:" + instance.getServiceId() + ", result:" + r); return r; &#125;&#125; c)在主类中加入@EnableDiscoveryClient注解 激活Eureka中的DiscoveryClient实现 d)配置application.properties 12345#微服务的名称spring.application.name=compute-serviceserver.port=2222#指定服务注册中心得位置eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 三.服务消费者a)Ribbon1）加入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2）在应用主类中加入@EnableDiscoveryClient注解 添加发现服务的能力，创建RestTemplate实例，添加@LoadBalanced注解开启均衡负载能力 123456789101112@SpringBootApplication@EnableDiscoveryClientpublic class RibbonApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125;&#125; 3)创建ConsumerController来消费，直接通过RestTemplate来调用服务 123456789@RestControllerpublic class ConsumerController &#123; @Autowired RestTemplate restTemplate; @RequestMapping(value = "/add", method = RequestMethod.GET) public String add() &#123; return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&amp;b=20", String.class).getBody(); &#125;&#125; 4)配置application.properties 123spring.application.name=ribbon-consumerserver.port=3333eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ b)Feign1)加入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)在应用主类加入@EnableFeignClients注解 开启Fegin功能 12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 3)定义想要调用的服务的接口 1234567//通过FeignClient("compute-service")绑定接口对应的service服务@FeignClient("compute-service")public interface ComputeClient &#123; //是这里的value在起作用，它映射到服务提供方的方法 @RequestMapping(method = RequestMethod.GET, value = "/add") Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);&#125; 4)在web层调用接口 123456789@RestControllerpublic class ConsumerController &#123; @Autowired ComputeClient computeClient; @RequestMapping(value = "/add", method = RequestMethod.GET) public Integer add() &#123; return computeClient.add(10, 20); &#125;&#125; 5)配置application.properties 123spring.application.name=feign-consumerserver.port=3333eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 四.断路器a)Ribbon引入Hystrix1)添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 2)在主类中加入@EnableCircuitBreaker注解 开启断路器功能 12345678910111213@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic class RibbonApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125;&#125; 3)改造原来的服务消费方式，新增ComputeService类，在使用的函数上增加@HystrixCommand注解指定回调方法 123456789101112@Servicepublic class ComputeService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "addServiceFallback") public String addService() &#123; return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&amp;b=20", String.class).getBody(); &#125; public String addServiceFallback() &#123; return "error"; &#125;&#125; 4)将提rest接口的Controller改为调用ComputeService的addService 123456789@RestControllerpublic class ConsumerController &#123; @Autowired private ComputeService computeService; @RequestMapping(value = "/add", method = RequestMethod.GET) public String add() &#123; return computeService.addService(); &#125;&#125; b)Feign使用Hystrix1)使用@FeignClient注解中的fallback属性指定回调类 12345@FeignClient(value = "compute-service", fallback = ComputeClientHystrix.class)public interface ComputeClient &#123; @RequestMapping(method = RequestMethod.GET, value = "/add") Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);&#125; 2)创建回调类ComputeClientHystrix，实现含有@FeignClient注解的接口 1234567@Componentpublic class ComputeClientHystrix implements ComputeClient &#123; @Override public Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b) &#123; return -9999; &#125;&#125; 五.分布式配置中心a)构建Config Server1)加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; 2)在应用主类中加入@EnableConfigServer注解 开启Config Server 1234567@EnableConfigServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 3)配置application.properties，添加服务和git信息 1234567891011spring.application.name=config-serverserver.port=7001# git管理配置#git仓库的位置spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/SpringBoot-Learning/#配置仓库路径下的相对搜索路径，可配置多个spring.cloud.config.server.git.searchPaths=Chapter9-1-4/config-repo#访问git仓库的用户名spring.cloud.config.server.git.username=username#访问git仓库的用户密码spring.cloud.config.server.git.password=password b)微服务端映射配置1）加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 2)创建bootstrap.properties配置，指定config server 12345678#&#123;application&#125;-&#123;profile&#125;.properties对应的配置文件spring.application.name=didispacespring.cloud.config.profile=dev#对应当前配置的git分支spring.cloud.config.label=master#配置中心的地址spring.cloud.config.uri=http://localhost:7001/server.port=7002 3)创建一个Rest Api来返回配置中心的from属性 1234567891011@RefreshScope@RestControllerclass TestController &#123; //通过@Value("$&#123;from&#125;")绑定配置服务中配置的from属性 @Value("$&#123;from&#125;") private String from; @RequestMapping("/from") public String from() &#123; return this.from; &#125;&#125; 六.分布式配置中心(高可用)a)config-server配置1)新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)配置application.properties 123456789spring.application.name=config-serverserver.port=7001# 配置服务注册中心eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/# git仓库配置spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/SpringCloud-Learning/spring.cloud.config.server.git.searchPaths=Chapter1-1-8/config-repospring.cloud.config.server.git.username=usernamespring.cloud.config.server.git.password=password 3)新增@EnableDiscoveryClient注解，将config-server注册到服务注册中心 12345678@EnableDiscoveryClient@EnableConfigServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; b)config-client配置1)新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)配置bootstrap.properties 12345678spring.application.name=didispaceserver.port=7002eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/#开启通过服务访问Config Server的功能spring.cloud.config.discovery.enabled=true#指定Config Server注册的服务名spring.cloud.config.discovery.serviceId=config-serverspring.cloud.config.profile=dev 3)在应用主类新增@EnableDiscoveryClient注解 用来发现config-server服务 c)配置刷新1)新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 七.服务网关a)使用Zuul1)添加依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)在应用主类加入@EnableZuulProxy注解 开启Zuul 12345678@EnableZuulProxy//整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker@SpringCloudApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 3)配置application.properties 12spring.application.name=api-gatewayserver.port=5555 c)服务路由1)通过url直接映射(不太友好) 123# routes to urlzuul.routes.api-a-url.path=/api-a-url/**zuul.routes.api-a-url.url=http://localhost:2222/ 2)通过serviceId 12345zuul.routes.api-a.path=/api-a/**zuul.routes.api-a.serviceId=service-Azuul.routes.api-b.path=/api-b/**zuul.routes.api-b.serviceId=service-Beureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ d)服务过滤1)创建Zuul过滤器 1234567891011121314151617181920212223242526272829303132public class AccessFilter extends ZuulFilter &#123; private static Logger log = LoggerFactory.getLogger(AccessFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format("%s request to %s", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter("accessToken"); if(accessToken == null) &#123; log.warn("access token is empty"); //令zuul过滤该请求，不对其进行路由 ctx.setSendZuulResponse(false); //设置了其返回的错误码 ctx.setResponseStatusCode(401); return null; &#125; log.info("access token ok"); return null; &#125;&#125; 2)实例化自定义过滤器 1234567891011@EnableZuulProxy@SpringCloudApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125; @Bean public AccessFilter accessFilter() &#123; return new AccessFilter(); &#125;&#125; 八.高可用服务注册中心a)创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2 1234spring.application.name=eureka-serverserver.port=1111eureka.instance.hostname=peer1eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/ b)创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1 1234spring.application.name=eureka-serverserver.port=1112eureka.instance.hostname=peer2eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/ c)对hosts文件进行转换 12127.0.0.1 peer1127.0.0.1 peer2 d)将项目打包(mvn install),通过spring.profiles.active属性启动peer1和peer2 12java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2 e)服务注册与发现 修改application.properties 1234spring.application.name=compute-serviceserver.port=2222#将服务指向了peer1和peer2eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/ 九.消息总线a)RabbitMQ1)扩展config-client-eureka，加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2)在配置文件中增加关于RabbitMQ的连接和用户信息 需要先安装RabbitMQ，然后创建一个用户，为用户添加角色和权限 1234spring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=springcloudspring.rabbitmq.password=123456 3)指定刷新范围 /bus/refresh接口还提供了destination参数，用来定位具体要刷新的应用程序。比如，我们可以请求/bus/refresh?destination=customers:9000，destination参数除了可以定位具体的实例之外，还可以用来定位具体的服务。定位服务的原理是通过使用Spring的PathMatecher（路径匹配）来实现，比如：/bus/refresh?destination=customers:**，该请求会触发customers服务的所有实例进行刷新。 4)架构优化 在之前的架构中，服务的配置更新需要通过向具体服务中的某个实例发送请求，再触发对整个服务集群的配置更新。 1.在Config Server中也引入Spring Cloud Bus，将配置服务端也加入到消息总线中来。 2./bus/refresh请求不在发送到具体服务实例上，而是发送给Config Server，并通过destination参数来指定需要更新配置的服务或实例。 b)Kafka1)整合Spring Cloud Bus,替换依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-kafka&lt;/artifactId&gt;&lt;/dependency&gt; 2)Kafka的配置 123456属性名 说明 默认值spring.cloud.stream.kafka.binder.brokers Kafka的服务端列表 localhostspring.cloud.stream.kafka.binder.defaultBrokerPort Kafka服务端的默认端口，当brokers属性中没有配置端口信息时，就会使用这个默认端口 9092spring.cloud.stream.kafka.binder.zkNodes Kafka服务端连接的ZooKeeper节点列表 localhostspring.cloud.stream.kafka.binder.defaultZkPort ZooKeeper节点的默认端口，当zkNodes属性中没有配置端口信息时，就会使用这个默认端口]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
