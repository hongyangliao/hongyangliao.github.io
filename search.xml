<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[supervisor使用方法]]></title>
    <url>%2F2018%2F04%2F27%2FPython%2Fsupervisor%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景自己做个python小项目，发现公司都是使用supervisor管理项目的运行状态，因此学习一下 介绍Supervisor (http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。 安装supervisor安装非常方便，在python环境下，直接使用pip安装即可1pip install supervisor supervisord配置supervisor属于c/s模式，需要启动一个服务supervisord，而我们使用supervisorctl来管理其他应用程序安装完supervisor后，可以使用以下命令将默认配置文件输出1echo_supervisord_conf &gt; /etc/supervisord.conf 配置文件详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254[unix_http_server] file=/tmp/supervisor.sock ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行 的。如果不设置的话，supervisorctl也就不能用了 不设置的话，默认为none。 非必须设置 ;chmod=0700 ; 这个简单，就是修改上面的那个socket文件的权限为0700 不设置的话，默认为0700。 非必须设置;chown=nobody:nogroup ; 这个一样，修改上面的那个socket文件的属组为user.group 不设置的话，默认为启动supervisord进程的用户及属组。非必须设置;username=user ; 使用supervisorctl连接的时候，认证的用户 不设置的话，默认为不需要用户。 非必须设置;password=123 ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密 如：&#123;SHA&#125;82ab876d1387bfafe46cc1c8a2ef074eae50cb1d 默认不设置。。。非必须设置;[inet_http_server] ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他 不设置的话，默认为不开启。非必须设置;port=127.0.0.1:9001 ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。 这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它;username=user ; 这个和上面的uinx_http_server一个样。非必须设置;password=123 ; 这个也一个样。非必须设置[supervisord] ;这个主要是定义supervisord这个服务端进程的一些参数的 这个必须设置，不设置，supervisor就不用干活了logfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。 默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置logfile_maxbytes=50MB ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日 志文件。当设置为0时，表示不限制文件大小 默认值是50M，非必须设置。 logfile_backups=10 ; 日志文件保持的数量，上面的日志文件大于50M时，就会生成一个新文件。文件 数量大于10时，最初的老文件被新文件覆盖，文件数量将保持为10 当设置为0时，表示不限制文件的数量。 默认情况下为10。。。非必须设置loglevel=info ; 日志级别，有critical, error, warn, info, debug, trace, or blather等 默认为info。。。非必须设置项pidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。 默认为$CWD/supervisord.pid。。。非必须设置nodaemon=false ; 如果是true，supervisord进程将在前台运行 默认为false，也就是后台以守护进程运行。。。非必须设置minfds=1024 ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。 系统的文件描述符在这里设置cat /proc/sys/fs/file-max 默认情况下为1024。。。非必须设置minprocs=200 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。 ulimit -u这个命令，可以查看linux下面用户的最大进程数 默认为200。。。非必须设置;umask=022 ; 进程创建文件的掩码 默认为022。。非必须设置项;user=chrism ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。 我这里面设置的这个用户，也可以对supervisord进行管理 默认情况是不设置。。。非必须设置项;identifier=supervisor ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个 supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个 supervisor设置不同的标识符了 默认是supervisord。。。非必需设置;directory=/tmp ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动 supervisord进程之前，会先切换到这个目录 默认不设置。。。非必须设置;nocleanup=true ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程 产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当 然不想日志被清除了。所以可以设置为true 默认是false，有调试需求的同学可以设置为true。。。非必须设置;childlogdir=/tmp ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。 默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c "import tempfile;print tempfile.gettempdir()" 非必须设置;environment=KEY="value" ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的 这些环境变量也会被子进程继承。 小例子：environment=name="haha",age="hehe" 默认为不设置。。。非必须设置;strip_ansi=false ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI 序列呢？就是我们的\n,\t这些东西。 默认为false。。。非必须设置; the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor] ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这 个选项必须要开启的supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] ;这个主要是针对supervisorctl的一些配置 serverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket 路径，注意这个是和前面的[unix_http_server]对应的 默认值就是unix:///tmp/supervisor.sock。。非必须设置;serverurl=http://127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径 注意这个和前面的[inet_http_server]对应 默认就是http://127.0.0.1:9001。。。非必须项 ;username=chris ; 用户名 默认空。。非必须设置;password=123 ; 密码 默认空。。非必须设置;prompt=mysupervisor ; 输入用户名密码时候的提示符 默认supervisor。。非必须设置;history_file=~/.sc_history ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令 默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非 必须设置; The below sample program section shows all possible program subsection values,; create one or more 'real' program: sections to be able to control them under; supervisor.;[program:theprogramname] ;这个就是咱们要管理的子进程了，":"后面的是名字，最好别乱写和实际进程 有点关联最好。这样的program我们可以设置一个或多个，一个program就是 要被管理的一个进程;command=/bin/cat ; 这个就是我们的要启动进程的命令路径了，可以带参数 例子：/home/test.py -a 'hehe' 有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是 守护进程。这个想想也知道了，比如说command=service httpd start。 httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令 这已经不是严格意义的子进程了。 这个是个必须设置的项;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字， 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个 进程都用同一个进程名吧。 ;numprocs=1 ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置 默认为1 。。非必须设置;directory=/tmp ; 进程运行前，会前切换到这个目录 默认不设置。。。非必须设置;umask=022 ; 进程掩码，默认none，非必须;priority=999 ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭 默认值为999 。。非必须设置;autostart=true ; 如果是true的话，子进程将在supervisord启动后被自动启动 默认就是true 。。非必须设置;autorestart=unexpected ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected 和true。如果为false的时候，无论什么情况下，都不会被重新启动， 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无 条件的重启;startsecs=1 ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启 动成功了 默认值为1 。。非必须设置;startretries=3 ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把 此进程的状态置为FAIL 默认值为3 。。非必须设置;exitcodes=0,2 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的 退出码是expected的。;stopsignal=QUIT ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号 默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected 非必须设置;stopwaitsecs=10 ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该 子进程发送一个强制kill的信号。 默认为10秒。。非必须设置;stopasgroup=false ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。 需要注意的是，该选项发送的是stop信号 默认为false。。非必须设置。。;killasgroup=false ; 这个和上面的stopasgroup类似，不过发送的是kill信号;user=chrism ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来 管理该program 默认不设置。。。非必须设置项;redirect_stderr=true ; 如果为true，则stderr的日志会被写入stdout日志文件中 默认为false，非必须设置;stdout_logfile=/a/path ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件;stdout_logfile_maxbytes=1MB ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50;stdout_logfile_backups=10 ; 和[supervisord]定义的一样。默认10;stdout_capture_maxbytes=1MB ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout 发送信息，而supervisor可以根据信息，发送相应的event。 默认为0，为0的时候表达关闭管道。。。非必须项;stdout_events_enabled=false ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将 触发supervisord发送PROCESS_LOG_STDOUT类型的event 默认为false。。。非必须设置;stderr_logfile=/a/path ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置;stderr_logfile_maxbytes=1MB ; 这个出现好几次了，就不重复了;stderr_logfile_backups=10 ; 这个也是;stderr_capture_maxbytes=1MB ; 这个一样，和stdout_capture一样。 默认为0，关闭状态;stderr_events_enabled=false ; 这个也是一样，默认为false;environment=A="1",B="2" ; 这个是该子进程的环境变量，和别的子进程是不共享的;serverurl=AUTO ; ; The below sample eventlistener section shows all possible; eventlistener subsection values, create one or more 'real'; eventlistener: sections to be able to handle event notifications; sent by supervisor.;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进 程，不过它干的活是订阅supervisord发送的event。他的名字就叫 listener了。我们可以在listener里面做一系列处理，比如报警等等 楼主这两天干的活，就是弄的这玩意;command=/bin/eventlistener ; 这个和上面的program一样，表示listener的可执行文件的路径;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就 OK了;numprocs=1 ; 相同的listener启动的个数;events=EVENT ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送 ;buffer_size=10 ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer 超过10的时候，最旧的event将会被清除，并把新的event放进去。 默认值为10。。非必须选项;directory=/tmp ; 进程执行前，会切换到这个目录下执行 默认为不切换。。。非必须;umask=022 ; 淹没，默认为none，不说了;priority=-1 ; 启动优先级，默认-1，也不扯了;autostart=true ; 是否随supervisord启动一起启动，默认true;autorestart=unexpected ; 是否自动重启，和program一个样，分true,false,unexpected等，注意 unexpected和exitcodes的关系;startsecs=1 ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1;startretries=3 ; 失败最大尝试次数，默认3;exitcodes=0,2 ; 期望或者说预料中的进程退出码，;stopsignal=QUIT ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程 那么会被认为是正常维护，退出码也被认为是expected中的;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10);stopasgroup=false ; send stop signal to the UNIX process group (default false);killasgroup=false ; SIGKILL the UNIX process group (def false);user=chrism ;设置普通用户，可以用来管理该listener进程。 默认为空。。非必须设置;redirect_stderr=true ; 为true的话，stderr的log会并入stdout的log里面 默认为false。。。非必须设置;stdout_logfile=/a/path ; 这个不说了，好几遍了;stdout_logfile_maxbytes=1MB ; 这个也是;stdout_logfile_backups=10 ; 这个也是;stdout_events_enabled=false ; 这个其实是错的，listener是不能发送event;stderr_logfile=/a/path ; 这个也是;stderr_logfile_maxbytes=1MB ; 这个也是;stderr_logfile_backups ; 这个不说了;stderr_events_enabled=false ; 这个也是错的，listener不能发送event;environment=A="1",B="2" ; 这个是该子进程的环境变量 默认为空。。。非必须设置;serverurl=AUTO ; override serverurl computation (childutils); The below sample group section shows all possible group values,; create one or more 'real' group: sections to create "heterogeneous"; process groups.;[group:thegroupname] ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了 我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来 的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再 会对组里面的单个program进行管理了;programs=progname1,progname2 ; 组成员，用逗号分开 这个是个必须的设置项;priority=999 ; 优先级，相对于组和组之间说的 默认999。。非必须选项; The [include] section can just contain the "files" setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面 就有点大了。我们可以把配置信息写到多个文件中，然后include过来;files = relative/directory/*.ini 我自己更改了很多文件放置的位置,因为/tmp目录下会定时清空，引起不必要的问题，更改完配置文件就可以启动supervisord的服务了1supervisord -C /etc/supervisord.conf supervisordctl的使用还记得supervisord的配置吗，最后有一个[include]配置，里面存放着如何管理的应用程序信息，可以在某一目录下创建这些文件12[include]files = /etc/supervisord.d/*.ini 配置,如下图，就是/etc/supervisor.d/supervisor_refesh_blog.ini(名字随便取)的配置12345678910[program:refresh_blog] ;refresh_blog 是应用程序的唯一标识，不能重复command=python refresh_blog.py ;执行程序的命令;numprocess=1 ;进程数;process_name ; 进程名，不填为[program:refresh_blog]中refresh_blog的名称directory=/root/python_protjects/refresh_blog ;应用程序启动的目录user=root ;启动的用户autorestart=true ;是否自动重启redirect_stderr=true ;把 stderr 重定向到 stdout，默认 falsestdout_logfile=/var/log/supervisord/refresh_blog.log ;日志文件地址loglevel=info ;日志级别 使用supervisorctl使用supervisorctl时启动时指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件1supervisorctl -c /etc/supervisord.conf 输入命令后会进入supervisorctl的交互界面123456status # 查看程序状态stop refrsh_blog # 关闭 refrsh_blog 程序start refrsh_blog # 启动 refrsh_blog 程序restart userefrsh_blogrcenter # 重启 refrsh_blog 程序reread ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序update ＃ 重启配置文件修改过的程序 也可以直接在终端运行：123456$ supervisorctl status$ supervisorctl stop refrsh_blog$ supervisorctl start refrsh_blog$ supervisorctl restart refrsh_blog$ supervisorctl reread$ supervisorctl update 参考http://liyangliang.me/posts/2015/06/using-supervisor/ http://blog.51cto.com/lixcto/1539136]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2018%2F04%2F03%2FGit%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本地项目关联远程仓库在GitHub上创建一个空项目进入本地项目的目录,初始化项目为Git项目1git init 将本地项目与远程仓库关联1git remote add origin git@github.com:hongyangliao/test.git origin为远程仓库别名，git@github.com:hongyangliao/test.git为远程仓库地址 将项目中的代码推到远程仓库中123456# 添加到暂存区git add .# 提交到本地仓库git commit -m 'init porject'# 推送代码到远程仓库git push -u origin master 关联远程分支1git checkout -b dev origin/dev 此命令作用是创建一个本地分支并关联远程分支，同时转换到刚刚创建的本地分支 dev为本地分支 origin/dev为远程分支 创建本地分支并推送到远程1234# 创建并切换到创建的本地分支git checkout -b dev# 提交本地分支作为远程分支git push origin dev:dev 远程仓库的使用查看当前配置的远程仓库1git remote -v 分支的使用创建分支1git branch dev 删除本地分支1git branch -d dev 删除远端分支1git push origin :dev 切换分支1git checkout dev 查看远程分支1git branch -a 查看本地分支1git branch]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jjwt实现jwt]]></title>
    <url>%2F2018%2F02%2F06%2FWeb%2F%E4%BD%BF%E7%94%A8jjwt%E5%AE%9E%E7%8E%B0jwt%2F</url>
    <content type="text"><![CDATA[背景介绍 项目中使用了Spring Boot,由于是微服务架构,现在不想使用Session来存储用户登录状态 (session是基于cookie实现的)态,选择JWT来存储用户ID,作为身份认证的凭证. JWT介绍(Json Web Token)Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 JWT构成jwt由三部分组成:头部(header),载体(payload),签名(signature),如下所示 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiIxIiwibmJmIjoxNTE3OTEzMzY3LCJleHAiOjE1MTc5MTMzNzd9.9QTvNWuwJsma84AfeXK4JO9ozOy4owmZJws9IZ2DMAI 头部(header)1234&#123; 'typ':'JWT', 'alg':'HS256',&#125; 头部由两部分组成, typ:类型 alg:加密方式 将头部进行Base64加密,得到1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 载荷(payload)存储有效信息的地方,一般有三部分组成 1.标准中注册的声明(不强制使用)1234567iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 2.公共的声明 存放公共信息的地方 3.私有的声明 存放私有信息的地方 注意:载荷中不要存储敏感信息 如下为我使用的载荷12345&#123; 'nbf':'Tue Feb 06 18:36:07 CST 2018', 'exp':'Tue Feb 06 18:36:17 CST 2018', 'userId':'1'&#125; 将载体进行Base64加密,得到1eyJ1c2VySWQiOiIxIiwibmJmIjoxNTE3OTEzMzY3LCJleHAiOjE1MTc5MTMzNzd9 签名(signature)将得到头部和载荷加密的字符串拼接起来,使用头部中alg指定的加密算法,加上secret盐加密,得到19QTvNWuwJsma84AfeXK4JO9ozOy4owmZJws9IZ2DMAI 最后将三部分使用’.’拼接起来即可使用方法当用户登录通过验证,返回一个jwt给前端,前端在请求头中添加一个’Authorization’字段,每次请求带上此请求头,后端根据userId判断用户身份 具体实现项目使用的jjwt,在pom.xml中引入如下依赖1234567&lt;!-- jwt --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 项目结构如下1234567jwt |_ excption |_JwtParameterEmptyException.java |_JwtParameterIllegalException.java |_jwtInfo.java |_JwtPayload.java |_JwtUtils.java 其中exception包下是自定义异常 JwtInfo.java代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.liao.common.jwt;/** * Jwt信息(生成Jwt时所需要的参数) * * @author hongyangliao * @ClassName: JwtInfo * @Date 17-12-28 下午3:42 */public class JwtInfo extends JwtPayload &#123; /** * 签名的加密方式 * 一般取值: HS256 */ private String alg; /** * 签名的盐 */ private String secret; /** * 过期时间 单位毫秒 */ private long expiresMillis; /** * 生成的token信息 */ private String token; public String getAlg() &#123; return alg; &#125; public void setAlg(String alg) &#123; this.alg = alg; &#125; public String getSecret() &#123; return secret; &#125; public void setSecret(String secret) &#123; this.secret = secret; &#125; public long getExpiresMillis() &#123; return expiresMillis; &#125; public void setExpiresMillis(long expiresMillis) &#123; this.expiresMillis = expiresMillis; &#125; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; @Override public String toString() &#123; return "JwtInfo&#123;" + "alg='" + alg + '\'' + ", secret='" + secret + '\'' + ", expiresMillis=" + expiresMillis + ", token='" + token + '\'' + '&#125;'; &#125;&#125; JwtPayload.java代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.liao.common.jwt;import java.util.Date;/*** * Jwt载荷 * * @ClassName: JwtPayload * @author hongyangliao * @Date 17-12-28 下午2:34 */public class JwtPayload &#123; /** * 用户id */ private String userId; /** * 过期时间 */ private Date exp; /** * 在什么时间之前不能使用 */ private Date nbf; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public Date getExp() &#123; return exp; &#125; public void setExp(Date exp) &#123; this.exp = exp; &#125; public Date getNbf() &#123; return nbf; &#125; public void setNbf(Date nbf) &#123; this.nbf = nbf; &#125; @Override public String toString() &#123; return "JwtPayload&#123;" + "userId='" + userId + '\'' + ", exp=" + exp + ", nbf=" + nbf + '&#125;'; &#125;&#125; JwtUtils.java代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package com.liao.common.jwt;import com.liao.common.jwt.exception.JwtParameterEmptyException;import com.liao.common.jwt.exception.JwtParameterIllegalException;import io.jsonwebtoken.*;import org.apache.commons.lang3.StringUtils;import java.util.Date;/*** * Jwt工具类(使用jjwt) * * @ClassName: JwtUtils * @author hongyangliao * @Date 17-12-28 下午6:16 */public class JwtUtils &#123; /*** * 生成Jwt * * @Title: generateJwt * @author: hongyangliao * @Date: 17-12-28 下午4:38 * @param jwtInfo jwt信息 需要传入 alg,userId,secret,expiresMillis * @return java.lang.String * @throws */ public static String generateJwt(JwtInfo jwtInfo) throws JwtParameterEmptyException, JwtParameterIllegalException, SignatureException &#123; if (jwtInfo == null) &#123; throw new JwtParameterEmptyException("Jwt传入参数为空"); &#125; //参数校验 String alg = jwtInfo.getAlg(); String userId = jwtInfo.getUserId(); String secret = jwtInfo.getSecret(); long expiresMillis = jwtInfo.getExpiresMillis(); if (StringUtils.isBlank(alg) || StringUtils.isBlank(userId) || StringUtils.isBlank(secret)) &#123; throw new JwtParameterEmptyException("Jwt传入参数为空"); &#125; if (expiresMillis &lt; 0) &#123; throw new JwtParameterIllegalException("过期时间不合法"); &#125; Date currentDate = new Date(); long dateMillis = currentDate.getTime() + expiresMillis; Date date = new Date(dateMillis); //如果jwtInfo.getAlg()不正确会抛出SignatureException SignatureAlgorithm signatureAlgorithm = null; try &#123; signatureAlgorithm = SignatureAlgorithm.forName(jwtInfo.getAlg()); &#125; catch (SignatureException e) &#123; throw new SignatureException("(alg)签名加密方式不正确"); &#125; String token = null; if (signatureAlgorithm != null) &#123; //设置头部,载体,签名 token = Jwts.builder() .setHeaderParam("typ", "JWT") .setHeaderParam("alg", jwtInfo.getAlg()) .claim("userId", jwtInfo.getUserId()) .setNotBefore(currentDate) .setExpiration(date) .signWith(signatureAlgorithm, secret) .compact(); &#125; return token; &#125; /*** * 根据信息获取Jwt载体 * * @Title: getJwtPayload * @author: hongyangliao * @Date: 17-12-28 下午4:59 * @param jwtInfo jwt信息, 需要传入token,secret * @return com.ducetech.common.jwt.JwtPayload Jwt载体 * @throws */ public static JwtPayload getJwtPayload(JwtInfo jwtInfo) throws JwtParameterEmptyException, ExpiredJwtException, UnsupportedJwtException, MalformedJwtException, SignatureException, IllegalArgumentException &#123; //参数校验 if (jwtInfo == null) &#123; throw new JwtParameterEmptyException("Jwt传入参数为空"); &#125; String secret = jwtInfo.getSecret(); String token = jwtInfo.getToken(); if (StringUtils.isBlank(secret) || StringUtils.isBlank(token)) &#123; throw new JwtParameterEmptyException("Jwt传入参数为空"); &#125; Jws&lt;Claims&gt; jws = null; try &#123; jws = Jwts.parser().setSigningKey(jwtInfo.getSecret()).parseClaimsJws(jwtInfo.getToken()); &#125; catch (ExpiredJwtException ee) &#123; //token已过期 throw ee; &#125; catch (UnsupportedJwtException ujw) &#123; //签名算法不支持 throw ujw; &#125; catch (MalformedJwtException mje) &#123; //失去载体 throw mje; &#125; catch (SignatureException se) &#123; //jwt签名不匹配 throw se; &#125; catch (IllegalArgumentException iae) &#123; //不能序列化载体 throw iae; &#125; JwtPayload jwtPayload = new JwtPayload(); if (jws != null) &#123; Claims claims = jws.getBody(); String userId = claims.get("userId", String.class); jwtPayload.setUserId(userId); jwtPayload.setExp(claims.getExpiration()); jwtPayload.setNbf(claims.getNotBefore()); &#125; return jwtPayload; &#125; public static void main(String[] args) &#123; JwtInfo jwtInfo = new JwtInfo(); jwtInfo.setAlg("HS256"); jwtInfo.setUserId("1"); jwtInfo.setSecret("hongyangliao"); jwtInfo.setExpiresMillis(10000L); String jwt = generateJwt(jwtInfo); System.out.println(jwt); jwtInfo.setToken(jwt); JwtPayload jwtPayload = getJwtPayload(jwtInfo); System.out.println(jwtPayload); &#125;&#125; 参考 什么是 JWT – JSON WEB TOKEN]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slf4j+logback配置详解]]></title>
    <url>%2F2018%2F01%2F03%2FLog%2Fslf4j-logback%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[近来在重构项目,原有项目日志部分使用SpringBoot的默认配置 默认情况下，Spring Boot会用Logback来记录日志,如果依赖了spring-boot-starter或者spring-boot-starter-logging则使用在spring-boot-1...RELEASE.jar下org/springframework/boot/logging/logback中的base.xml defaults.xml console-appender.xml file-appender.xml作为配置文件 网上发现一个logback的配置详解,地址为https://segmentfault.com/a/1190000008315137 留下作为记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="/apps/log/ducetech"/&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="ducetech-upms"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="appLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，false：表示只用当前logger的appender-ref，true：表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;!--&lt;logger name="org.hibernate" level="error"&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!-- druid logger --&gt; &lt;logger name="druid.sql" level="info" additivity="false"&gt; &lt;appender-ref ref="stdout"/&gt; &lt;/logger&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="error" additivity="false"&gt; &lt;appender-ref ref="stdout"/&gt; &lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="stdout"/&gt; &lt;appender-ref ref="appLogAppender"/&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>Log</category>
      </categories>
      <tags>
        <tag>slf4j</tag>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Mybatis时使用Druid数据库连接池]]></title>
    <url>%2F2018%2F01%2F02%2FSpring%2FSpringBoot%E6%95%B4%E5%90%88Mybatis%E6%97%B6%E4%BD%BF%E7%94%A8Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在SpringBoot项目中,增加如下依赖1234567891011121314151617181920 &lt;!-- spring mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.26&lt;/version&gt;&lt;/dependency&gt; 在resource目录下,创建jdbc.properties配置文件,加入以下配置1234567891011121314151617181920212223242526272829303132#数据库配置spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsespring.datasource.username=adminspring.datasource.password=adminspring.datasource.driver-class-name=com.mysql.jdbc.Driver# 连接池配置# 初始化大小，最小，最大spring.datasource.initialSize=5 spring.datasource.minIdle=5 spring.datasource.maxActive=20 # 配置获取连接等待超时的时间spring.datasource.maxWait=60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.timeBetweenEvictionRunsMillis=60000 # 配置一个连接在池中最小生存的时间，单位是毫秒spring.datasource.minEvictableIdleTimeMillis=300000# 测试连接是否有效的sqlspring.datasource.validationQuery=select 'x'# 建议配置为true，不影响性能，并且保证安全性# 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效spring.datasource.testWhileIdle=true# 申请连接时执行validationQuery检测连接是否有效spring.datasource.testOnBorrow=false# 归还连接时执行validationQuery检测连接是否有效spring.datasource.testOnReturn=false# 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：# 监控统计用的filter:stat# 日志用的filter:log4j# 防御sql注入的filter:wallspring.datasource.filters=stat,log4j,wall 创建数据源配置类DataSourceConfig.java,代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291package com.liao.mybatis;import com.alibaba.druid.pool.DruidDataSource;import org.mybatis.spring.annotation.MapperScan;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.sql.SQLException;/** * 数据源 * * @author hongyangliao * @ClassName: DataSourceConfig * @Date 18-1-2 下午8:56 */@Configuration@MapperScan("com.liao.**.dao")public class DataSourceConfig &#123; private static final Logger logger = LoggerFactory.getLogger(DataSourceConfig.class); @Autowired private JdbcConfig jdbcConfig; @Bean @Primary //在同样的DataSource中，首先使用被标注的DataSource public DataSource dataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(jdbcConfig.getUrl()); druidDataSource.setUsername(jdbcConfig.getUserName()); druidDataSource.setPassword(jdbcConfig.getPassword()); druidDataSource.setInitialSize(jdbcConfig.getInitialSize()); druidDataSource.setMinIdle(jdbcConfig.getMinIdle()); druidDataSource.setMaxActive(jdbcConfig.getMaxActive()); druidDataSource.setTimeBetweenEvictionRunsMillis(jdbcConfig.getTimeBetweenEvictionRunsMillis()); druidDataSource.setMinEvictableIdleTimeMillis(jdbcConfig.getMinEvictableIdleTimeMillis()); druidDataSource.setValidationQuery(jdbcConfig.getValidationQuery()); druidDataSource.setTestWhileIdle(jdbcConfig.isTestWhileIdle()); druidDataSource.setTestOnBorrow(jdbcConfig.isTestOnBorrow()); druidDataSource.setTestOnReturn(jdbcConfig.isTestOnReturn()); druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(jdbcConfig.getMaxPoolPreparedStatementPerConnectionSize()); try &#123; druidDataSource.setFilters(jdbcConfig.getFilters()); &#125; catch (SQLException e) &#123; if (logger.isInfoEnabled()) &#123; logger.info(e.getMessage(), e); &#125; &#125; return druidDataSource; &#125; /** * Jdbc配置类 * * @author hongyangliao * @ClassName: JdbcConfig * @Date 18-1-2 下午9:00 */ @PropertySource(value = "classpath:jdbc.properties") @Component public static class JdbcConfig &#123; /** * 数据库用户名 */ @Value("$&#123;spring.datasource.username&#125;") private String userName; /** * 驱动名称 */ @Value("$&#123;spring.datasource.driver-class-name&#125;") private String driverClass; /** * 数据库连接url */ @Value("$&#123;spring.datasource.url&#125;") private String url; /** * 数据库密码 */ @Value("$&#123;spring.datasource.password&#125;") private String password; /** * 数据库连接池初始化大小 */ @Value("$&#123;spring.datasource.initialSize&#125;") private int initialSize; /** * 数据库连接池最小最小连接数 */ @Value("$&#123;spring.datasource.minIdle&#125;") private int minIdle; /** * 数据库连接池最大连接数 */ @Value("$&#123;spring.datasource.maxActive&#125;") private int maxActive; /** * 获取连接等待超时的时间 */ @Value("$&#123;spring.datasource.maxWait&#125;") private long maxWait; /** * 多久检测一次 */ @Value("$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;") private long timeBetweenEvictionRunsMillis; /** * 连接在池中最小生存的时间 */ @Value("$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;") private long minEvictableIdleTimeMillis; /** * 测试连接是否有效的sql */ @Value("$&#123;spring.datasource.validationQuery&#125;") private String validationQuery; /** * 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，检测连接是否有效 */ @Value("$&#123;spring.datasource.testWhileIdle&#125;") private boolean testWhileIdle; /** * 申请连接时,检测连接是否有效 */ @Value("$&#123;spring.datasource.testOnBorrow&#125;") private boolean testOnBorrow; /** * 归还连接时,检测连接是否有效 */ @Value("$&#123;spring.datasource.testOnReturn&#125;") private boolean testOnReturn; /** * PSCache大小 */ @Value("$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;") private int maxPoolPreparedStatementPerConnectionSize; /** * 通过别名的方式配置扩展插件 */ @Value("$&#123;spring.datasource.filters&#125;") private String filters; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getDriverClass() &#123; return driverClass; &#125; public void setDriverClass(String driverClass) &#123; this.driverClass = driverClass; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getInitialSize() &#123; return initialSize; &#125; public void setInitialSize(int initialSize) &#123; this.initialSize = initialSize; &#125; public int getMinIdle() &#123; return minIdle; &#125; public void setMinIdle(int minIdle) &#123; this.minIdle = minIdle; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public long getMaxWait() &#123; return maxWait; &#125; public void setMaxWait(long maxWait) &#123; this.maxWait = maxWait; &#125; public long getTimeBetweenEvictionRunsMillis() &#123; return timeBetweenEvictionRunsMillis; &#125; public void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) &#123; this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis; &#125; public long getMinEvictableIdleTimeMillis() &#123; return minEvictableIdleTimeMillis; &#125; public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) &#123; this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis; &#125; public String getValidationQuery() &#123; return validationQuery; &#125; public void setValidationQuery(String validationQuery) &#123; this.validationQuery = validationQuery; &#125; public boolean isTestWhileIdle() &#123; return testWhileIdle; &#125; public void setTestWhileIdle(boolean testWhileIdle) &#123; this.testWhileIdle = testWhileIdle; &#125; public boolean isTestOnBorrow() &#123; return testOnBorrow; &#125; public void setTestOnBorrow(boolean testOnBorrow) &#123; this.testOnBorrow = testOnBorrow; &#125; public boolean isTestOnReturn() &#123; return testOnReturn; &#125; public void setTestOnReturn(boolean testOnReturn) &#123; this.testOnReturn = testOnReturn; &#125; public int getMaxPoolPreparedStatementPerConnectionSize() &#123; return maxPoolPreparedStatementPerConnectionSize; &#125; public void setMaxPoolPreparedStatementPerConnectionSize(int maxPoolPreparedStatementPerConnectionSize) &#123; this.maxPoolPreparedStatementPerConnectionSize = maxPoolPreparedStatementPerConnectionSize; &#125; public String getFilters() &#123; return filters; &#125; public void setFilters(String filters) &#123; this.filters = filters; &#125; &#125;&#125; 创建Session工厂配置类SessionFactoryConfig.java,代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.liao.mybatis;import java.io.IOException;import javax.sql.DataSource;import org.mybatis.spring.SqlSessionFactoryBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.ClassPathResource;import org.springframework.transaction.annotation.EnableTransactionManagement;@Configuration@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt;public class SessionFactoryConfig &#123; /** * mybatis 配置路径 */ private static String MYBATIS_CONFIG = "mybatis-config.xml"; @Autowired private DataSource dataSource; /*** * 创建sqlSessionFactoryBean * 并且设置configtion 如驼峰命名.等等 * 设置mapper 映射路径 * 设置datasource数据源 * * @Title: createSqlSessionFactoryBean * @author: hongyangliao * @Date: 18-1-3 上午9:52 * @param * @return org.mybatis.spring.SqlSessionFactoryBean sqlSessionFactoryBean实例 * @throws */ @Bean(name = "sqlSessionFactory") public SqlSessionFactoryBean createSqlSessionFactoryBean() throws IOException &#123; SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean(); // 设置mybatis configuration 扫描路径 sqlSessionFactory.setConfigLocation(new ClassPathResource(MYBATIS_CONFIG)); // 设置datasource sqlSessionFactory.setDataSource(dataSource); return sqlSessionFactory; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nginx作为静态文件服务器]]></title>
    <url>%2F2017%2F12%2F20%2FNginx%2F%E4%BD%BF%E7%94%A8nginx%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍:自己希望搭建个文件服务器用来下载常用的开发软件修改nginx的配置文件,加上如下内容12345678910111213141516server &#123; listen 80; # 填写域名或者ip地址 server_name test.hongyangliao.com; # 文件存储目录 root /data; location / &#123; # 显示索引 autoindex on; # 显示大小 autoindex_exact_size on; # 显示时间 autoindex_localtime on; &#125;&#125; 重启nginx服务,输入test.hongyangliao.com即可查看,页面如下图所示1234567891011Index of /../apache-maven-3.5.2-bin.tar.gz 20-Dec-2017 02:30 8738691apache-tomcat-7.0.82.tar.gz 20-Dec-2017 02:30 8997403apache-tomcat-8.0.48.tar.gz 20-Dec-2017 02:30 9390469apache-tomcat-8.5.24.tar.gz 20-Dec-2017 02:30 9487006jdk-7u80-linux-x64.tar.gz 20-Dec-2017 02:52 153530841jdk-8u151-linux-x64.tar.gz 20-Dec-2017 01:20 189736377nginx-1.8.1.tar.gz 20-Dec-2017 00:25 833473redis-4.0.6.tar.gz 20-Dec-2017 02:31 1723533 点击相应的文件即可下载,如想在下载linux服务器下载,使用如下命令1wget http://test.hongyangliao.com/apache-maven-3.5.2-bin.tar.gz]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移gitolite]]></title>
    <url>%2F2017%2F12%2F08%2FGit%2F%E8%BF%81%E7%A7%BBgitolite%2F</url>
    <content type="text"><![CDATA[在新的服务器上安装gitolite,并为其指定管理员进入gitolite初始化后的目录gitolite-admin内，将之前线上config和keydir内文件全部拷贝过来git push,提交将原有的giolite的repositories下的文件拷贝到新服务器的repositories下在gitolite-admin中git pull获取最新的数据]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos6.5服务器安装]]></title>
    <url>%2F2017%2F11%2F29%2FLinux%2FCentos6-5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[关闭安全子系统12sed -i "s/SELINUX=enforcing/SELINUX=disabled/" /etc/selinux/configsetenforce 0 安装wget1yum -y install wget 更改默认镜像为阿里镜像1234cd /etc/yum.repos.d &amp;&amp; mv CentOS-Base.repo CentOS-Base.repo.bakwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repoyum makecacheyum clean all 安装zip1yum install -y unzip zip 安装vim1yum install -y vim 安装scp1yum -y install openssh-clients 安装相关依赖1yum -y install gcc-c++ tcl gettext-devel pcre-devel openssl openssl-devel bison flexcurl-devel expat-devel zlib-devel autoconf automake libtool python ncurses-devellibjpeg-devel e2fsprogs-devel sqlite-devel libcurl-devel speex-devel ldns-devel libeditdevelreadline-devel ncurses-devel pam-develnumactl 安装screen会话1yum -y install screen 安装ntpdate时间同步工具12yum -y install ntpdateecho '0 1 * * * ntpdate cn.pool.ntp.org;hwclock -w' &gt;&gt; /var/spool/cron/root 安装java123456789101112mkdir -p /opt/javacd ~ &amp;&amp; wget http://oss.hongyangliao.com/jdk-8u151-linux-x64.tar.gzmv jdk-8u151-linux-x64.tar.gz /opt/java/cd /opt/javatar -xzvf jdk-8u151-linux-x64.tar.gzrm -rf jdk-8u151-linux-x64.tar.gzecho 'export JAVA_HOME=/opt/java/jdk1.8.0_151' &gt;&gt; /etc/profileecho 'exportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/rt.jar' &gt;&gt; /etc/profileecho 'export PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profilecd /usr/binln -s -f /opt/java/jdk1.8.0_151/jre/bin/javaln -s -f /opt/java/jdk1.8.0_151/bin/javac 安装Tomcat12345678cd ~ &amp;&amp; wget http://oss.hongyangliao.com/apache-tomcat-8.5.24.tar.gzmv apache-tomcat-8.5.24.tar.gz /usr/local/cd /usr/localtar -xzvf apache-tomcat-8.5.24.tar.gzmv apache-tomcat-8.5.24 tomcat8mv apache-tomcat-8.5.24.tar.gz /usr/local/srcecho 'export CATALINA_HOME=/usr/local/tomcat8' &gt;&gt; /etc/profilesource /etc/profile 设置Tomcat自启12cd /etc/init.dtouch tomcat8 &amp;&amp; chmod 755 tomcat8 &amp;&amp; vim tomcat8 添加如下命令,注意JAVA_HOME,CATALANA_HOME1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bash # # tomcat startup script for the Tomcat server # # chkconfig: 345 80 20 # description: start the tomcat deamon # # Source function library . /etc/rc.d/init.d/functionsprog=tomcat8JAVA_HOME=/opt/java/jdk1.8.0_151export JAVA_HOME CATALANA_HOME=/usr/local/tomcat8export CATALINA_HOME case "$1" instart) echo "Starting Tomcat..." $CATALANA_HOME/bin/startup.sh ;;stop) echo "Stopping Tomcat..." $CATALANA_HOME/bin/shutdown.sh ;;restart) echo "Stopping Tomcat..." $CATALANA_HOME/bin/shutdown.sh sleep 2 echo echo "Starting Tomcat..." $CATALANA_HOME/bin/startup.sh ;;*) echo "Usage: $prog &#123;start|stop|restart&#125;" ;;esacexit 0 执行以下命令12chkconfig --add tomcat8chkconfig --level 345 tomcat8 安装nginx下载并安装nginx12345cd &amp;&amp; wget http://oss.hongyangliao.com/nginx-1.8.1.tar.gzmv nginx-1.8.1.tar.gz /usr/local/srccd /usr/local/src &amp;&amp; tar -xzvf nginx-1.8.1.tar.gzcd nginx-1.8.1 &amp;&amp; ./configure --prefix=/usr/local/nginxmake &amp;&amp; make install 设置nginx自启123cd /etc/init.dtouch nginxvim nginx 添加如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!/bin/bash # nginx Startup script for the Nginx HTTP Server # # chkconfig: - 85 15 # description: Nginx is a high-performance web and proxy server. # It has a lot of features, but it's not for everyone. # processname: nginx # pidfile: /usr/local/nginx/logs/nginx.pid # config: /usr/local/nginx/conf/nginx.conf nginxd=/usr/local/nginx/sbin/nginx nginx_config=/usr/local/nginx/conf/nginx.conf nginx_pid=/usr/local/nginx/nginx.pid RETVAL=0 prog="nginx"# Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ $&#123;NETWORKING&#125; = "no" ] &amp;&amp; exit 0 [ -x $nginxd ] || exit 0 # Start nginx daemons functions. start() &#123; if [ -e $nginx_pid ];then echo "nginx already running...." exit 1 fi echo -n $"Starting $prog: " daemon $nginxd -c $&#123;nginx_config&#125; RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx return $RETVAL &#125; # Stop nginx daemons functions. stop() &#123; echo -n $"Stopping $prog: " killproc $nginxd RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid &#125; # reload nginx service functions. reload() &#123; echo -n $"Reloading $prog: " $nginxd -s reload #if your nginx version is below 0.8, please use this command: "kill -HUP `cat $&#123;nginx_pid&#125;`" RETVAL=$? echo &#125; # See how we were called. case "$1" instart) start ;; stop) stop ;; reload) reload ;; restart) stop start ;; status) status $prog RETVAL=$? ;; *) echo $"Usage: $prog &#123;start|stop|restart|reload|status|help&#125;" exit 1 esac exit $RETVAL 保存,接着设置自启1234chmod +x /etc/init.d/nginxchkconfig --add nginxchkconfig --level 345 nginx onservice nginx start 安装Redis12345cd &amp;&amp; wget http://oss.hongyangliao.com/redis-4.0.6.tar.gztar -zxvf redis-4.0.6.tar.gzcd redis-4.0.6 &amp;&amp; make PREFIX=/usr/local/redis installcd /usr/local/redis &amp;&amp; mkdir confcp ~/redis-4.0.6/redis.conf /usr/local/redis/conf 设置后端启动Redis1vim /usr/local/redis/conf/redis.conf 将 daemonize yes 以后端模式启动12345################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize yes 设置redis服务自启12cd /etc/init.d &amp;&amp; touch redis &amp;&amp; chmod +x redisvim redis 在redis文件中添加如下内容,注意redis_pid的值123cd /etc/init.dtouch redisvim redis 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/bin/bash## chkconfig: - 85 15# script_name:redisd# description:redis daemon# config: /usr/local/redis/conf/redisd.conf# pidfile: /var/run/redis-server.pid#### BEGIN INIT INFO# Provides: redis### END INIT INFO# Source function library.. /etc/rc.d/init.d/functions#variablesredis_port='6379'redis_pid='/var/run/redis_'$redis_port'.pid'redis_server="/usr/local/redis/bin/redis-server"redis_conf="/usr/local/redis/conf/redis.conf"redis_cli="/usr/local/redis/bin/redis-cli"#functionfunction _start() &#123; if [ ! -e "$redis_pid" ];then "$redis_server" "$redis_conf" echo "redis service start.......OK" return 0 else echo "redis service is running !" return 1 fi&#125;function _stop() &#123; if [ -e "$redis_pid" ];then "$redis_cli" shutdown echo "redis service stop.......OK" sleep 1 return 0 else echo "redis service is not running !" return 1 fi&#125;function _status() &#123; if [ -e "$redis_pid" ];then echo "redis service is running !" return 0 else echo "redis service is not running !" return 1 fi&#125;#maincase "$1" in start) _start ;; stop) _stop ;; status) _status ;; *) echo "Usage: $0 &#123;start|stop|status&#125;"esac 接着123chkconfig --add redischkconfig --level 345 redis onservice redis start 设置给redis客户端设置软链接1ln -s /usr/local/redis/bin/redis-cli /usr/local/bin/redis-cli 安装mysql123456789wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmrpm -ivh mysql-community-release-el6-5.noarch.rpmyum install mysql-server/etc/init.d/mysqld startmysql_secure_installationmysql -uroot -puse mysql;GRANT ALL PRIVILEGES ON *.* TO 'admin'@'%' IDENTIFIED BY 'admin' WITH GRANT OPTION;FLUSH PRIVILEGES; 修改mysql数据库编码为UTF-8，修改/etc/my.cnf或者/etc/mysql/my.cnf文件123456[client]default-character-set = utf8[mysqld]default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci 重启mysql服务，并查看数据库编码123service mysqld restartmysql -uroot -pshow variables like '%char%'; 编码为以下即可123456789101112+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 安装Maven12345678910cd ~ &amp;&amp; wget http://oss.hongyangliao.com/apache-maven-3.5.2-bin.tar.gzmv apache-maven-3.5.2-bin.tar.gz /usr/local/cd /usr/local &amp;&amp; tar -xzvf apache-maven-3.5.2-bin.tar.gzmv apache-maven-3.5.2 mavenecho 'M2_HOME=/usr/local/maven' &gt;&gt; /etc/profileecho 'export PATH=$M2_HOME/bin:$PATH' &gt;&gt; /etc/profilesource /etc/profilemvn help:systemcp /usr/local/maven/conf/settings.xml /root/.m2/mv /usr/local/apache-maven-3.2.5-bin.tar.gz /usr/local/src/ 安装Git1yum -y install git 配置公钥1ssh-keygen -t rsa]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitclone非22端口clone项目]]></title>
    <url>%2F2017%2F11%2F21%2FGit%2Fgitclone%E9%9D%9E22%E7%AB%AF%E5%8F%A3clone%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[使用git clone命令clone项目时，如果repository的SSH端口不是标准22端口时（例如，SSH tunnel模式，等等），可以使用如下命令：1git clone ssh://git@hostname:port/.../xxx.git]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库设置utf-8编码]]></title>
    <url>%2F2017%2F11%2F20%2Fmysql%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AEutf-8%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[修改/etc/my.cnf或者/etc/mysql/my.cnf文件123456[client]default-character-set = utf8[mysqld]default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci 重启mysql,使用mysql客户端检查编码1show variables like '%char%'; 创建新数据库时使用UTF-8编码1create database 'test' default character set utf8 collate utf8_general_ci; 创建表,创建字段使用UTF-8编码12345create table test ( 'id' int(10) unsigned not null auto_increment, 'name' varchar(50) character set utf8 default '', primary key('id') ) default charset=utf8;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat部署项目]]></title>
    <url>%2F2017%2F09%2F07%2FTomcat%2Ftomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[第一种方式 将项目打包成war，然后放入tomcat根目录/webapps下，启动tomcat，tomcat自动将war解压，然后删除war包,或者之间放入项目编译后的文件 第二种方式 项目放在任意目录，如/apps/hello-world 在tomcat根目录/conf中的server.xml的节点中加入 1&lt;Context path="/hello-world" docBase="/apps/hello-world"/&gt; 第三种方式(推荐) 项目放在任意目录，如/apps/hello-world 在tomcat根目录/conf中新建Catalina/localhost目录,在localhost目录中创建一个xml文件，文件名称任意(最好使用下项目名),在文件中加入 1&lt;Context path="/hello-world" docBase="/apps/hello-world"/&gt; 注意第三种方法的优点，可以定义别名。服务器端运行的项目名称为path，外部访问的URL则使用XML的文件名]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat用户配置]]></title>
    <url>%2F2017%2F08%2F30%2FTomcat%2Ftomcat%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[进入Tomcat目录下conf/tomcat-users.xml 1.Tomcat6配置管理员信息 在配置文件节点下添加 123&lt;role rolename="admin"/&gt;&lt;role rolename="manager"/&gt;&lt;user username="admin" password="admin" roles="admin,manager"/&gt; 2.Tomcat7配置管理员信息 在配置文件节点下添加 123&lt;role rolename="admin-gui"/&gt;&lt;role rolename="manager-gui"/&gt;&lt;user username="admin" password="admin" roles=" admin-gui,manager-gui "/&gt;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见操作]]></title>
    <url>%2F2017%2F08%2F29%2FLinux%2FLinux%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[注意事项：基于centos6 修改密码 passwd passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被root用户锁定；如果root用户运行passwd ，可以设置或修改任何用户的密码 passwd 命令后面不接任何参数或用户名，则表示修改当前用户的密码 修改主机名 hostname 1.使用hostname修改主机名 hostname hongyangliao-pc 2.修改/etc/sysconfig/network配置文件 修改HOSTNAME=hongyangliao-pc 3.修改本机域名解析文件/etc/hosts 将原来的主机名换为hongyangliao-pc 修改SSH端口 1.修改SSH端口配置文件/etc/ssh/sshd_config,将Port的值换为想要的端口号 2.重启SSH服务，service sshd restart iptabels配置 1.修改/etc/sysconfig/iptbles 文件 123456789101112131415161718192021222324*filter# Allow loopback (lo0) traffic and drop all traffic to 127/8 that doesn't use the lo0 interface-A INPUT -i lo -j ACCEPT-A INPUT -i ! lo -d 127.0.0.0/8 -j REJECT# Accept established inbound connections-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# Allow all outbound traffic-A OUTPUT -j ACCEPT# Allow HTTP and HTTPS connections-A INPUT -p tcp --dport 80 -j ACCEPT-A INPUT -p tcp --dport 443 -j ACCEPT# Allow SSH/SFTP# Change the value 22 if you are using a non-standard port-A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT# Allow FTP# Purely optional, but required for WordPress to install its own plugins or update itself.-A INPUT -p tcp -m state --state NEW --dport 21 -j ACCEPT# Allow PING# Again, optional. Some disallow this altogether.-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# Reject ALL other inbound-A INPUT -j REJECT-A FORWARD -j REJECTCOMMIT 2.保存 1service iptables save 3.重启 1service iptables restart 4.添加到自启动 1chkconfig iptables on ssh scp 免密码登录 1.本机创建公钥、密钥 ssh-keygen -t rsa 一路回车到底 2.把公钥id_rsa.pub复制到远程服务器上~/.ssh目录并命名为authorized_keys 远程复制scp 1.从本地复制到远程服务器 1# scp local_file remote_username@remote_ip:remote_folder 2.从远程服务器复制到本地 1# $scp remote_username@remote_ip:remote_file local_folder 网络设置 1.修改ip地址 修改对应网卡的ip地址 1# vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改以下内容 12345678910DEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0BOOTPROTO=static #设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址BROADCAST=192.168.0.255 #对应的子网广播地址HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址IPADDR=12.168.1.2 #如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址IPV6INIT=noIPV6_AUTOCONF=noNETMASK=255.255.255.0 #网卡对应的网络掩码NETWORK=192.168.1.0 #网卡对应的网络地址ONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备 2.修改网关 修改对应网卡的网关 1# vim /etc/sysconfig/network 修改以下内容 123NETWORKING=yes #表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动HOSTNAME=centos #设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应GATEWAY=192.168.1.1 #设置本机连接的网关的IP地址。例如，网关为10.0.0.2 3.修改DNS 修改对应网卡的DNS 1# vim /etc/resolv.conf 修改以下内容 12nameserver 8.8.8.8 #google域名服务器nameserver 8.8.4.4 #google域名服务器 4.重启网卡 1# /etc/init.d/network restart 5.简单设置(推荐) 修改对应网卡的网关 1# vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改以下内容 123456789BOOTPROTO=static #静态指定ipONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备IPADDR=192.168.149.10 #ip地址NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.149.2 #网关DNS1=8.8.8.8 #DNSDNS2=4.4.4.4IPV6INIT=noDEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0 重启网卡 1# /etc/init.d/network restart 安装Apache 1.停止并卸载系统自带的httpd服务 12345# service httpd stop# ps -ef | grep httpd# kill -9 pid号（逐个删除）# rpm -qa |grep httpd# rpm -e httpd软件包 2.安装Apache 12# wget http://mirrors.hust.edu.cn/apache//httpd/httpd-2.2.34.tar.gz# tar -zxvf httpd-2.2.34.tar.gz 3.编译 12# ./configure --prefix=/usr/local/apache# make &amp;&amp; make install 4.启动、停止、重启 启动Apache：/usr/local/apache2/bin/apachectl start 停止Apache：/usr/local/apache2/bin/apachectl stop 重启Apache：/usr/local/apache2/bin/apachectl restart 5.网站放置目录 网站放在/usr/local/apache/htdocs 安装php 1.安装依赖文件(不安装的话，自己会安装很多东西) 12# yum groupinstall "Development tools"# yum install libxml2-devel gd-devel libmcrypt-devel libcurl-devel openssl-devel 2.安装php 12# wget http://php.net/get/php-5.5.38.tar.gz/from/this/mirror# tar -zxvf php-5.5.38.tar.gz 3.编译 12# ./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache/bin/apxs --disable-cli --enable-shared --with-libxml-dir --with-gd --with-openssl --enable-mbstring --with-mysqli --with-mysql --enable-opcache --enable-mysqlnd --enable-zip --enable-fpm --enable-fastcgi --with-zlib-dir --with-pdo-mysql --with-jpeg-dir --with-freetype-dir --with-curl --without-pdo-sqlite --without-sqlite3 --with-mcrypt=/usr/local/libmcrypt/# make &amp;&amp; make install 4.注意事项 如果出现 configure: error: mcrypt.h not found. Please reinstall libmcrypt 则需安装libmcrypt 12345# wget ftp://mcrypt.hellug.gr/pub/crypto/mcrypt/attic/libmcrypt/libmcrypt-2.5.7.tar.gz# tar -zxvf libmcrypt-2.5.7.tar.gz# cd libmcrypt-2.5.7# ./configure prefix=/usr/local/libmcrypt/# make &amp;&amp; make install 5.配置Apache中的PHP环境 修改Apache的配置文件httpd.conf 在LoadModule中添加： 1LoadModule php5_module modules/libphp5.so 在AddType application/x-gzip .gz .tgz下面添加： 12AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps 在DirectoryIndex增加 index.php，以便Apache识别PHP格式的index 123&lt;IfModule dir_module&gt; DirectoryIndex index.html index.php &lt;/IfModule&gt; 6.验证PHP环境 1# vim /usr/local/apache/htdocs/info.php 添加如下代码 12345&lt;?phpphpinfo();?&gt; 访问 http://locahost/info.php 可查看很多信息 安转rar1.安装依赖库 1# yum install -y gcc gcc-c++ autoconf wget 2.下载源码包 1# wget http://www.rarlab.com/rar/rarlinux-x64-5.3.0.tar.gz 3.解压编译 123456tar -zxvf rarlinux-x64-5.3.0.tar.gzcd rarmake &amp;&amp; make installcp -f rar_static /usr/local/bin/rar &amp;&amp; cp -f rar_static /usr/local/bin/unrarcd ..rm -rf rar 4.使用 12解压：rar x filename.rar压缩：rar a targetName.rar dirName]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql导出、导入]]></title>
    <url>%2F2017%2F08%2F10%2Fmysql%2Fmysql%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[mysql导出数据库、表1.导出数据和表结构1# mysqldump -u用户名 -p密码 数据库名 &gt; 文件名.sql 2.导出单表数据核单表1# mysqldump -u用户名 -p密码 数据库名 表名 &gt; 文件名.sql 3.只导出表结构1mysqldump -u用户名 -p密码 -d 数据库名 &gt; 文件名.sql mysql导出sql文件1.首先创建数据库1create database 数据库名 2.导入数据库 方法一： （1）选择数据库1use 数据库名 （2）导入数据1source sql文件路径 方法二：1mysql -u用户名 -p密码 数据库名 &lt; sql文件路径]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud 微服务 开发步骤]]></title>
    <url>%2F2017%2F07%2F09%2FSpring%2FSpringCloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%20%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[参考：http://blog.didispace.com/springcloud1/创建一个基础的Spring Boot工程,每个项目都需加上SpringCloud的依赖使用的是Brixton版本 12345678910111213141516171819202122232425262728&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 一.服务注册中心a)加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; b)在主程序中加入注解@EnableEurekaServer 启动一个服务注册中心 c)默认情况下，注册中心会将自己作为客户端需要禁用,配置application.properties 1234server.port=1111eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/ 二.服务提供方a)加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; b)实现处理接口，通过DiscoveryClient获取信息 12345678910111213@RestControllerpublic class ComputeController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(value = "/add" ,method = RequestMethod.GET) public Integer add(@RequestParam Integer a, @RequestParam Integer b) &#123; ServiceInstance instance = client.getLocalServiceInstance(); Integer r = a + b; logger.info("/add, host:" + instance.getHost() + ", service_id:" + instance.getServiceId() + ", result:" + r); return r; &#125;&#125; c)在主类中加入@EnableDiscoveryClient注解 激活Eureka中的DiscoveryClient实现 d)配置application.properties 12345#微服务的名称spring.application.name=compute-serviceserver.port=2222#指定服务注册中心得位置eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 三.服务消费者a)Ribbon1）加入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2）在应用主类中加入@EnableDiscoveryClient注解 添加发现服务的能力，创建RestTemplate实例，添加@LoadBalanced注解开启均衡负载能力 123456789101112@SpringBootApplication@EnableDiscoveryClientpublic class RibbonApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125;&#125; 3)创建ConsumerController来消费，直接通过RestTemplate来调用服务 123456789@RestControllerpublic class ConsumerController &#123; @Autowired RestTemplate restTemplate; @RequestMapping(value = "/add", method = RequestMethod.GET) public String add() &#123; return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&amp;b=20", String.class).getBody(); &#125;&#125; 4)配置application.properties 123spring.application.name=ribbon-consumerserver.port=3333eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ b)Feign1)加入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)在应用主类加入@EnableFeignClients注解 开启Fegin功能 12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 3)定义想要调用的服务的接口 1234567//通过FeignClient("compute-service")绑定接口对应的service服务@FeignClient("compute-service")public interface ComputeClient &#123; //是这里的value在起作用，它映射到服务提供方的方法 @RequestMapping(method = RequestMethod.GET, value = "/add") Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);&#125; 4)在web层调用接口 123456789@RestControllerpublic class ConsumerController &#123; @Autowired ComputeClient computeClient; @RequestMapping(value = "/add", method = RequestMethod.GET) public Integer add() &#123; return computeClient.add(10, 20); &#125;&#125; 5)配置application.properties 123spring.application.name=feign-consumerserver.port=3333eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 四.断路器a)Ribbon引入Hystrix1)添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 2)在主类中加入@EnableCircuitBreaker注解 开启断路器功能 12345678910111213@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic class RibbonApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125;&#125; 3)改造原来的服务消费方式，新增ComputeService类，在使用的函数上增加@HystrixCommand注解指定回调方法 123456789101112@Servicepublic class ComputeService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "addServiceFallback") public String addService() &#123; return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&amp;b=20", String.class).getBody(); &#125; public String addServiceFallback() &#123; return "error"; &#125;&#125; 4)将提rest接口的Controller改为调用ComputeService的addService 123456789@RestControllerpublic class ConsumerController &#123; @Autowired private ComputeService computeService; @RequestMapping(value = "/add", method = RequestMethod.GET) public String add() &#123; return computeService.addService(); &#125;&#125; b)Feign使用Hystrix1)使用@FeignClient注解中的fallback属性指定回调类 12345@FeignClient(value = "compute-service", fallback = ComputeClientHystrix.class)public interface ComputeClient &#123; @RequestMapping(method = RequestMethod.GET, value = "/add") Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);&#125; 2)创建回调类ComputeClientHystrix，实现含有@FeignClient注解的接口 1234567@Componentpublic class ComputeClientHystrix implements ComputeClient &#123; @Override public Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b) &#123; return -9999; &#125;&#125; 五.分布式配置中心a)构建Config Server1)加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; 2)在应用主类中加入@EnableConfigServer注解 开启Config Server 1234567@EnableConfigServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 3)配置application.properties，添加服务和git信息 1234567891011spring.application.name=config-serverserver.port=7001# git管理配置#git仓库的位置spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/SpringBoot-Learning/#配置仓库路径下的相对搜索路径，可配置多个spring.cloud.config.server.git.searchPaths=Chapter9-1-4/config-repo#访问git仓库的用户名spring.cloud.config.server.git.username=username#访问git仓库的用户密码spring.cloud.config.server.git.password=password b)微服务端映射配置1）加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 2)创建bootstrap.properties配置，指定config server 12345678#&#123;application&#125;-&#123;profile&#125;.properties对应的配置文件spring.application.name=didispacespring.cloud.config.profile=dev#对应当前配置的git分支spring.cloud.config.label=master#配置中心的地址spring.cloud.config.uri=http://localhost:7001/server.port=7002 3)创建一个Rest Api来返回配置中心的from属性 1234567891011@RefreshScope@RestControllerclass TestController &#123; //通过@Value("$&#123;from&#125;")绑定配置服务中配置的from属性 @Value("$&#123;from&#125;") private String from; @RequestMapping("/from") public String from() &#123; return this.from; &#125;&#125; 六.分布式配置中心(高可用)a)config-server配置1)新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)配置application.properties 123456789spring.application.name=config-serverserver.port=7001# 配置服务注册中心eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/# git仓库配置spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/SpringCloud-Learning/spring.cloud.config.server.git.searchPaths=Chapter1-1-8/config-repospring.cloud.config.server.git.username=usernamespring.cloud.config.server.git.password=password 3)新增@EnableDiscoveryClient注解，将config-server注册到服务注册中心 12345678@EnableDiscoveryClient@EnableConfigServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; b)config-client配置1)新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)配置bootstrap.properties 12345678spring.application.name=didispaceserver.port=7002eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/#开启通过服务访问Config Server的功能spring.cloud.config.discovery.enabled=true#指定Config Server注册的服务名spring.cloud.config.discovery.serviceId=config-serverspring.cloud.config.profile=dev 3)在应用主类新增@EnableDiscoveryClient注解 用来发现config-server服务 c)配置刷新1)新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 七.服务网关a)使用Zuul1)添加依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 2)在应用主类加入@EnableZuulProxy注解 开启Zuul 12345678@EnableZuulProxy//整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker@SpringCloudApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 3)配置application.properties 12spring.application.name=api-gatewayserver.port=5555 c)服务路由1)通过url直接映射(不太友好) 123# routes to urlzuul.routes.api-a-url.path=/api-a-url/**zuul.routes.api-a-url.url=http://localhost:2222/ 2)通过serviceId 12345zuul.routes.api-a.path=/api-a/**zuul.routes.api-a.serviceId=service-Azuul.routes.api-b.path=/api-b/**zuul.routes.api-b.serviceId=service-Beureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ d)服务过滤1)创建Zuul过滤器 1234567891011121314151617181920212223242526272829303132public class AccessFilter extends ZuulFilter &#123; private static Logger log = LoggerFactory.getLogger(AccessFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format("%s request to %s", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter("accessToken"); if(accessToken == null) &#123; log.warn("access token is empty"); //令zuul过滤该请求，不对其进行路由 ctx.setSendZuulResponse(false); //设置了其返回的错误码 ctx.setResponseStatusCode(401); return null; &#125; log.info("access token ok"); return null; &#125;&#125; 2)实例化自定义过滤器 1234567891011@EnableZuulProxy@SpringCloudApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125; @Bean public AccessFilter accessFilter() &#123; return new AccessFilter(); &#125;&#125; 八.高可用服务注册中心a)创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2 1234spring.application.name=eureka-serverserver.port=1111eureka.instance.hostname=peer1eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/ b)创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1 1234spring.application.name=eureka-serverserver.port=1112eureka.instance.hostname=peer2eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/ c)对hosts文件进行转换 12127.0.0.1 peer1127.0.0.1 peer2 d)将项目打包(mvn install),通过spring.profiles.active属性启动peer1和peer2 12java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2 e)服务注册与发现 修改application.properties 1234spring.application.name=compute-serviceserver.port=2222#将服务指向了peer1和peer2eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/ 九.消息总线a)RabbitMQ1)扩展config-client-eureka，加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2)在配置文件中增加关于RabbitMQ的连接和用户信息 需要先安装RabbitMQ，然后创建一个用户，为用户添加角色和权限 1234spring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=springcloudspring.rabbitmq.password=123456 3)指定刷新范围 /bus/refresh接口还提供了destination参数，用来定位具体要刷新的应用程序。比如，我们可以请求/bus/refresh?destination=customers:9000，destination参数除了可以定位具体的实例之外，还可以用来定位具体的服务。定位服务的原理是通过使用Spring的PathMatecher（路径匹配）来实现，比如：/bus/refresh?destination=customers:**，该请求会触发customers服务的所有实例进行刷新。 4)架构优化 在之前的架构中，服务的配置更新需要通过向具体服务中的某个实例发送请求，再触发对整个服务集群的配置更新。 1.在Config Server中也引入Spring Cloud Bus，将配置服务端也加入到消息总线中来。 2./bus/refresh请求不在发送到具体服务实例上，而是发送给Config Server，并通过destination参数来指定需要更新配置的服务或实例。 b)Kafka1)整合Spring Cloud Bus,替换依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-kafka&lt;/artifactId&gt;&lt;/dependency&gt; 2)Kafka的配置 123456属性名 说明 默认值spring.cloud.stream.kafka.binder.brokers Kafka的服务端列表 localhostspring.cloud.stream.kafka.binder.defaultBrokerPort Kafka服务端的默认端口，当brokers属性中没有配置端口信息时，就会使用这个默认端口 9092spring.cloud.stream.kafka.binder.zkNodes Kafka服务端连接的ZooKeeper节点列表 localhostspring.cloud.stream.kafka.binder.defaultZkPort ZooKeeper节点的默认端口，当zkNodes属性中没有配置端口信息时，就会使用这个默认端口]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
